#!/usr/bin/env node
// @generated by xcodebuildmcp@0.0.1 on 2026-01-17T01:54:17.146Z. DO NOT EDIT.
import { Command } from 'commander';
import { createRuntime, createServerProxy } from 'mcporter';
import { createCallResult } from 'mcporter';

const embeddedServer = {
  "name": "xcodebuildmcp",
  "description": "Build/test Xcode projects via the XcodeBuildMCP MCP server using a local CLI wrapper for pi (no MCP support). Use when the user mentions Xcode, xcodebuild, iOS builds/tests, or XcodeBuildMCP.",
  "command": {
    "kind": "stdio",
    "command": "npx",
    "args": [
      "-y",
      "xcodebuildmcp@latest"
    ]
  },
  "source": {
    "kind": "local",
    "path": "<adhoc>"
  }
} as const;
const embeddedSchemas = {
  "build_device": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Path to derived data directory"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional arguments to pass to xcodebuild"
      },
      "preferXcodebuild": {
        "type": "boolean",
        "description": "Prefer xcodebuild over faster alternatives"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "clean": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Optional: Path where derived data might be located"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional xcodebuild arguments"
      },
      "preferXcodebuild": {
        "type": "boolean",
        "description": "If true, prefers xcodebuild over the experimental incremental build system, useful for when incremental build system fails."
      },
      "platform": {
        "type": "string",
        "enum": [
          "macOS",
          "iOS",
          "iOS Simulator",
          "watchOS",
          "watchOS Simulator",
          "tvOS",
          "tvOS Simulator",
          "visionOS",
          "visionOS Simulator"
        ],
        "description": "Optional: Platform to clean for (defaults to iOS). Choose from macOS, iOS, iOS Simulator, watchOS, watchOS Simulator, tvOS, tvOS Simulator, visionOS, visionOS Simulator"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "discover_projs": {
    "type": "object",
    "properties": {
      "workspaceRoot": {
        "type": "string",
        "description": "The absolute path of the workspace root to scan within."
      },
      "scanPath": {
        "type": "string",
        "description": "Optional: Path relative to workspace root to scan. Defaults to workspace root."
      },
      "maxDepth": {
        "type": "integer",
        "minimum": 0,
        "description": "Optional: Maximum directory depth to scan. Defaults to 5."
      }
    },
    "required": [
      "workspaceRoot"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_app_bundle_id": {
    "type": "object",
    "properties": {
      "appPath": {
        "type": "string",
        "description": "Path to the .app bundle to extract bundle ID from (full path to the .app directory)"
      }
    },
    "required": [
      "appPath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_device_app_path": {
    "type": "object",
    "properties": {
      "platform": {
        "type": "string",
        "enum": [
          "iOS",
          "watchOS",
          "tvOS",
          "visionOS"
        ],
        "description": "Target platform (defaults to iOS)"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "install_app_device": {
    "type": "object",
    "properties": {
      "appPath": {
        "type": "string",
        "description": "Path to the .app bundle to install (full path to the .app directory)"
      }
    },
    "required": [
      "appPath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "launch_app_device": {
    "type": "object",
    "properties": {
      "bundleId": {
        "type": "string",
        "description": "Bundle identifier of the app to launch (e.g., \"com.example.MyApp\")"
      }
    },
    "required": [
      "bundleId"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_devices": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_schemes": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "show_build_settings": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "start_device_log_cap": {
    "type": "object",
    "properties": {
      "bundleId": {
        "type": "string",
        "description": "Bundle identifier of the app to launch and capture logs for."
      }
    },
    "required": [
      "bundleId"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "stop_app_device": {
    "type": "object",
    "properties": {
      "processId": {
        "type": "number",
        "description": "Process ID (PID) of the app to stop"
      }
    },
    "required": [
      "processId"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "stop_device_log_cap": {
    "type": "object",
    "properties": {
      "logSessionId": {
        "type": "string",
        "description": "The session ID returned by start_device_log_cap."
      }
    },
    "required": [
      "logSessionId"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "test_device": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Path to derived data directory"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional arguments to pass to xcodebuild"
      },
      "preferXcodebuild": {
        "type": "boolean",
        "description": "Prefer xcodebuild over faster alternatives"
      },
      "platform": {
        "type": "string",
        "enum": [
          "iOS",
          "watchOS",
          "tvOS",
          "visionOS"
        ],
        "description": "Target platform (defaults to iOS)"
      },
      "testRunnerEnv": {
        "type": "object",
        "additionalProperties": {
          "type": "string"
        },
        "description": "Environment variables to pass to the test runner (TEST_RUNNER_ prefix added automatically)"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "doctor": {
    "type": "object",
    "properties": {
      "enabled": {
        "type": "boolean",
        "description": "Optional: dummy parameter to satisfy MCP protocol"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "start_sim_log_cap": {
    "type": "object",
    "properties": {
      "bundleId": {
        "type": "string",
        "description": "Bundle identifier of the app to capture logs for."
      },
      "captureConsole": {
        "type": "boolean",
        "description": "Whether to capture console output (requires app relaunch)."
      }
    },
    "required": [
      "bundleId"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "stop_sim_log_cap": {
    "type": "object",
    "properties": {
      "logSessionId": {
        "type": "string",
        "description": "The session ID returned by start_sim_log_cap."
      }
    },
    "required": [
      "logSessionId"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "build_macos": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Path where build products and other derived data will go"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional xcodebuild arguments"
      },
      "preferXcodebuild": {
        "type": "boolean",
        "description": "If true, prefers xcodebuild over the experimental incremental build system"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "build_run_macos": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Path where build products and other derived data will go"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional xcodebuild arguments"
      },
      "preferXcodebuild": {
        "type": "boolean",
        "description": "If true, prefers xcodebuild over the experimental incremental build system"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_mac_app_path": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Path to derived data directory"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional arguments to pass to xcodebuild"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_mac_bundle_id": {
    "type": "object",
    "properties": {
      "appPath": {
        "type": "string",
        "description": "Path to the macOS .app bundle to extract bundle ID from (full path to the .app directory)"
      }
    },
    "required": [
      "appPath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "launch_mac_app": {
    "type": "object",
    "properties": {
      "appPath": {
        "type": "string",
        "description": "Path to the macOS .app bundle to launch (full path to the .app directory)"
      },
      "args": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional arguments to pass to the app"
      }
    },
    "required": [
      "appPath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "stop_mac_app": {
    "type": "object",
    "properties": {
      "appName": {
        "type": "string",
        "description": "Name of the application to stop (e.g., \"Calculator\" or \"MyApp\")"
      },
      "processId": {
        "type": "number",
        "description": "Process ID (PID) of the application to stop"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "test_macos": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Path where build products and other derived data will go"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional xcodebuild arguments"
      },
      "preferXcodebuild": {
        "type": "boolean",
        "description": "If true, prefers xcodebuild over the experimental incremental build system"
      },
      "testRunnerEnv": {
        "type": "object",
        "additionalProperties": {
          "type": "string"
        },
        "description": "Environment variables to pass to the test runner (TEST_RUNNER_ prefix added automatically)"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "scaffold_ios_project": {
    "type": "object",
    "properties": {
      "projectName": {
        "type": "string",
        "minLength": 1,
        "description": "Name of the new project"
      },
      "outputPath": {
        "type": "string",
        "description": "Path where the project should be created"
      },
      "bundleIdentifier": {
        "type": "string",
        "description": "Bundle identifier (e.g., com.example.myapp). If not provided, will use com.example.projectname"
      },
      "displayName": {
        "type": "string",
        "description": "App display name (shown on home screen/dock). If not provided, will use projectName"
      },
      "marketingVersion": {
        "type": "string",
        "description": "Marketing version (e.g., 1.0, 2.1.3). If not provided, will use 1.0"
      },
      "currentProjectVersion": {
        "type": "string",
        "description": "Build number (e.g., 1, 42, 100). If not provided, will use 1"
      },
      "customizeNames": {
        "type": "boolean",
        "default": true,
        "description": "Whether to customize project names and identifiers. Default is true."
      },
      "deploymentTarget": {
        "type": "string",
        "description": "iOS deployment target (e.g., 18.4, 17.0). If not provided, will use 18.4"
      },
      "targetedDeviceFamily": {
        "type": "array",
        "items": {
          "type": "string",
          "enum": [
            "iphone",
            "ipad",
            "universal"
          ]
        },
        "description": "Targeted device families"
      },
      "supportedOrientations": {
        "type": "array",
        "items": {
          "type": "string",
          "enum": [
            "portrait",
            "landscape-left",
            "landscape-right",
            "portrait-upside-down"
          ]
        },
        "description": "Supported orientations for iPhone"
      },
      "supportedOrientationsIpad": {
        "type": "array",
        "items": {
          "type": "string",
          "enum": [
            "portrait",
            "landscape-left",
            "landscape-right",
            "portrait-upside-down"
          ]
        },
        "description": "Supported orientations for iPad"
      }
    },
    "required": [
      "projectName",
      "outputPath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "scaffold_macos_project": {
    "type": "object",
    "properties": {
      "projectName": {
        "type": "string",
        "minLength": 1,
        "description": "Name of the new project"
      },
      "outputPath": {
        "type": "string",
        "description": "Path where the project should be created"
      },
      "bundleIdentifier": {
        "type": "string",
        "description": "Bundle identifier (e.g., com.example.myapp). If not provided, will use com.example.projectname"
      },
      "displayName": {
        "type": "string",
        "description": "App display name (shown on home screen/dock). If not provided, will use projectName"
      },
      "marketingVersion": {
        "type": "string",
        "description": "Marketing version (e.g., 1.0, 2.1.3). If not provided, will use 1.0"
      },
      "currentProjectVersion": {
        "type": "string",
        "description": "Build number (e.g., 1, 42, 100). If not provided, will use 1"
      },
      "customizeNames": {
        "type": "boolean",
        "default": true,
        "description": "Whether to customize project names and identifiers. Default is true."
      },
      "deploymentTarget": {
        "type": "string",
        "description": "macOS deployment target (e.g., 15.4, 14.0). If not provided, will use 15.4"
      }
    },
    "required": [
      "projectName",
      "outputPath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "session-clear-defaults": {
    "type": "object",
    "properties": {
      "keys": {
        "type": "array",
        "items": {
          "type": "string",
          "enum": [
            "projectPath",
            "workspacePath",
            "scheme",
            "configuration",
            "simulatorName",
            "simulatorId",
            "deviceId",
            "useLatestOS",
            "arch"
          ]
        }
      },
      "all": {
        "type": "boolean"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "session-set-defaults": {
    "type": "object",
    "properties": {
      "projectPath": {
        "type": "string"
      },
      "workspacePath": {
        "type": "string"
      },
      "scheme": {
        "type": "string"
      },
      "configuration": {
        "type": "string"
      },
      "simulatorName": {
        "type": "string"
      },
      "simulatorId": {
        "type": "string"
      },
      "deviceId": {
        "type": "string"
      },
      "useLatestOS": {
        "type": "boolean"
      },
      "arch": {
        "type": "string",
        "enum": [
          "arm64",
          "x86_64"
        ]
      },
      "suppressWarnings": {
        "type": "boolean",
        "description": "When true, warning messages are filtered from build output to conserve context"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "session-show-defaults": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "boot_sim": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "build_run_sim": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Path where build products and other derived data will go"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional xcodebuild arguments"
      },
      "preferXcodebuild": {
        "type": "boolean",
        "description": "If true, prefers xcodebuild over the experimental incremental build system, useful for when incremental build system fails."
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "build_sim": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Path where build products and other derived data will go"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional xcodebuild arguments"
      },
      "preferXcodebuild": {
        "type": "boolean",
        "description": "If true, prefers xcodebuild over the experimental incremental build system, useful for when incremental build system fails."
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "describe_ui": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "get_sim_app_path": {
    "type": "object",
    "properties": {
      "platform": {
        "type": "string",
        "enum": [
          "iOS Simulator",
          "watchOS Simulator",
          "tvOS Simulator",
          "visionOS Simulator"
        ],
        "description": "Target simulator platform (Required)"
      }
    },
    "required": [
      "platform"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "install_app_sim": {
    "type": "object",
    "properties": {
      "appPath": {
        "type": "string",
        "description": "Path to the .app bundle to install (full path to the .app directory)"
      }
    },
    "required": [
      "appPath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "launch_app_logs_sim": {
    "type": "object",
    "properties": {
      "bundleId": {
        "type": "string",
        "description": "Bundle identifier of the app to launch (e.g., 'com.example.MyApp')"
      },
      "args": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional arguments to pass to the app"
      }
    },
    "required": [
      "bundleId"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "launch_app_sim": {
    "type": "object",
    "properties": {
      "bundleId": {
        "type": "string",
        "description": "Bundle identifier of the app to launch (e.g., 'com.example.MyApp')"
      },
      "args": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional arguments to pass to the app"
      }
    },
    "required": [
      "bundleId"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "list_sims": {
    "type": "object",
    "properties": {
      "enabled": {
        "type": "boolean",
        "description": "Optional flag to enable the listing operation."
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "open_sim": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "record_sim_video": {
    "type": "object",
    "properties": {
      "start": {
        "type": "boolean",
        "description": "Start recording if true"
      },
      "stop": {
        "type": "boolean",
        "description": "Stop recording if true"
      },
      "fps": {
        "type": "integer",
        "minimum": 1,
        "maximum": 120,
        "description": "Frames per second (default 30)"
      },
      "outputFile": {
        "type": "string",
        "description": "Destination MP4 path to move the recorded video to on stop"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "screenshot": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "stop_app_sim": {
    "type": "object",
    "properties": {
      "bundleId": {
        "type": "string",
        "description": "Bundle identifier of the app to stop (e.g., 'com.example.MyApp')"
      }
    },
    "required": [
      "bundleId"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "test_sim": {
    "type": "object",
    "properties": {
      "derivedDataPath": {
        "type": "string",
        "description": "Path where build products and other derived data will go"
      },
      "extraArgs": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional xcodebuild arguments"
      },
      "preferXcodebuild": {
        "type": "boolean",
        "description": "If true, prefers xcodebuild over the experimental incremental build system, useful for when incremental build system fails."
      },
      "testRunnerEnv": {
        "type": "object",
        "additionalProperties": {
          "type": "string"
        },
        "description": "Environment variables to pass to the test runner (TEST_RUNNER_ prefix added automatically)"
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "erase_sims": {
    "type": "object",
    "properties": {
      "shutdownFirst": {
        "type": "boolean",
        "description": "If true, shuts down the simulator before erasing."
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "reset_sim_location": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "set_sim_appearance": {
    "type": "object",
    "properties": {
      "mode": {
        "type": "string",
        "enum": [
          "dark",
          "light"
        ],
        "description": "The appearance mode to set (either \"dark\" or \"light\")"
      }
    },
    "required": [
      "mode"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "set_sim_location": {
    "type": "object",
    "properties": {
      "latitude": {
        "type": "number",
        "description": "The latitude for the custom location."
      },
      "longitude": {
        "type": "number",
        "description": "The longitude for the custom location."
      }
    },
    "required": [
      "latitude",
      "longitude"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "sim_statusbar": {
    "type": "object",
    "properties": {
      "dataNetwork": {
        "type": "string",
        "enum": [
          "clear",
          "hide",
          "wifi",
          "3g",
          "4g",
          "lte",
          "lte-a",
          "lte+",
          "5g",
          "5g+",
          "5g-uwb",
          "5g-uc"
        ],
        "description": "Data network type to display in status bar. Use \"clear\" to reset all overrides. Valid values: clear, hide, wifi, 3g, 4g, lte, lte-a, lte+, 5g, 5g+, 5g-uwb, 5g-uc."
      }
    },
    "required": [
      "dataNetwork"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "swift_package_build": {
    "type": "object",
    "properties": {
      "packagePath": {
        "type": "string",
        "description": "Path to the Swift package root (Required)"
      },
      "targetName": {
        "type": "string",
        "description": "Optional target to build"
      },
      "configuration": {
        "type": "string",
        "enum": [
          "debug",
          "release"
        ],
        "description": "Swift package configuration (debug, release)"
      },
      "architectures": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Target architectures to build for"
      },
      "parseAsLibrary": {
        "type": "boolean",
        "description": "Build as library instead of executable"
      }
    },
    "required": [
      "packagePath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "swift_package_clean": {
    "type": "object",
    "properties": {
      "packagePath": {
        "type": "string",
        "description": "Path to the Swift package root (Required)"
      }
    },
    "required": [
      "packagePath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "swift_package_list": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "swift_package_run": {
    "type": "object",
    "properties": {
      "packagePath": {
        "type": "string",
        "description": "Path to the Swift package root (Required)"
      },
      "executableName": {
        "type": "string",
        "description": "Name of executable to run (defaults to package name)"
      },
      "arguments": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Arguments to pass to the executable"
      },
      "configuration": {
        "type": "string",
        "enum": [
          "debug",
          "release"
        ],
        "description": "Build configuration: 'debug' (default) or 'release'"
      },
      "timeout": {
        "type": "number",
        "description": "Timeout in seconds (default: 30, max: 300)"
      },
      "background": {
        "type": "boolean",
        "description": "Run in background and return immediately (default: false)"
      },
      "parseAsLibrary": {
        "type": "boolean",
        "description": "Add -parse-as-library flag for @main support (default: false)"
      }
    },
    "required": [
      "packagePath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "swift_package_stop": {
    "type": "object",
    "properties": {
      "pid": {
        "type": "number",
        "description": "Process ID (PID) of the running executable"
      }
    },
    "required": [
      "pid"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "swift_package_test": {
    "type": "object",
    "properties": {
      "packagePath": {
        "type": "string",
        "description": "Path to the Swift package root (Required)"
      },
      "testProduct": {
        "type": "string",
        "description": "Optional specific test product to run"
      },
      "filter": {
        "type": "string",
        "description": "Filter tests by name (regex pattern)"
      },
      "configuration": {
        "type": "string",
        "enum": [
          "debug",
          "release"
        ],
        "description": "Swift package configuration (debug, release)"
      },
      "parallel": {
        "type": "boolean",
        "description": "Run tests in parallel (default: true)"
      },
      "showCodecov": {
        "type": "boolean",
        "description": "Show code coverage (default: false)"
      },
      "parseAsLibrary": {
        "type": "boolean",
        "description": "Add -parse-as-library flag for @main support (default: false)"
      }
    },
    "required": [
      "packagePath"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "button": {
    "type": "object",
    "properties": {
      "buttonType": {
        "type": "string",
        "enum": [
          "apple-pay",
          "home",
          "lock",
          "side-button",
          "siri"
        ]
      },
      "duration": {
        "type": "number",
        "minimum": 0
      }
    },
    "required": [
      "buttonType"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "gesture": {
    "type": "object",
    "properties": {
      "preset": {
        "type": "string",
        "enum": [
          "scroll-up",
          "scroll-down",
          "scroll-left",
          "scroll-right",
          "swipe-from-left-edge",
          "swipe-from-right-edge",
          "swipe-from-top-edge",
          "swipe-from-bottom-edge"
        ],
        "description": "The gesture preset to perform. Must be one of: scroll-up, scroll-down, scroll-left, scroll-right, swipe-from-left-edge, swipe-from-right-edge, swipe-from-top-edge, swipe-from-bottom-edge."
      },
      "screenWidth": {
        "type": "integer",
        "minimum": 1,
        "description": "Optional: Screen width in pixels. Used for gesture calculations. Auto-detected if not provided."
      },
      "screenHeight": {
        "type": "integer",
        "minimum": 1,
        "description": "Optional: Screen height in pixels. Used for gesture calculations. Auto-detected if not provided."
      },
      "duration": {
        "type": "number",
        "minimum": 0,
        "description": "Optional: Duration of the gesture in seconds."
      },
      "delta": {
        "type": "number",
        "minimum": 0,
        "description": "Optional: Distance to move in pixels."
      },
      "preDelay": {
        "type": "number",
        "minimum": 0,
        "description": "Optional: Delay before starting the gesture in seconds."
      },
      "postDelay": {
        "type": "number",
        "minimum": 0,
        "description": "Optional: Delay after completing the gesture in seconds."
      }
    },
    "required": [
      "preset"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "key_press": {
    "type": "object",
    "properties": {
      "keyCode": {
        "type": "integer",
        "minimum": 0,
        "maximum": 255
      },
      "duration": {
        "type": "number",
        "minimum": 0
      }
    },
    "required": [
      "keyCode"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "key_sequence": {
    "type": "object",
    "properties": {
      "keyCodes": {
        "type": "array",
        "items": {
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "minItems": 1
      },
      "delay": {
        "type": "number",
        "minimum": 0
      }
    },
    "required": [
      "keyCodes"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "long_press": {
    "type": "object",
    "properties": {
      "x": {
        "type": "integer"
      },
      "y": {
        "type": "integer"
      },
      "duration": {
        "type": "number",
        "exclusiveMinimum": 0
      }
    },
    "required": [
      "x",
      "y",
      "duration"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "swipe": {
    "type": "object",
    "properties": {
      "x1": {
        "type": "integer"
      },
      "y1": {
        "type": "integer"
      },
      "x2": {
        "type": "integer"
      },
      "y2": {
        "type": "integer"
      },
      "duration": {
        "type": "number",
        "minimum": 0
      },
      "delta": {
        "type": "number",
        "minimum": 0
      },
      "preDelay": {
        "type": "number",
        "minimum": 0
      },
      "postDelay": {
        "type": "number",
        "minimum": 0
      }
    },
    "required": [
      "x1",
      "y1",
      "x2",
      "y2"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "tap": {
    "type": "object",
    "properties": {
      "x": {
        "type": "integer"
      },
      "y": {
        "type": "integer"
      },
      "id": {
        "type": "string",
        "minLength": 1
      },
      "label": {
        "type": "string",
        "minLength": 1
      },
      "preDelay": {
        "type": "number",
        "minimum": 0
      },
      "postDelay": {
        "type": "number",
        "minimum": 0
      }
    },
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "touch": {
    "type": "object",
    "properties": {
      "x": {
        "type": "integer"
      },
      "y": {
        "type": "integer"
      },
      "down": {
        "type": "boolean"
      },
      "up": {
        "type": "boolean"
      },
      "delay": {
        "type": "number",
        "minimum": 0
      }
    },
    "required": [
      "x",
      "y"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "type_text": {
    "type": "object",
    "properties": {
      "text": {
        "type": "string",
        "minLength": 1
      }
    },
    "required": [
      "text"
    ],
    "additionalProperties": false,
    "$schema": "http://json-schema.org/draft-07/schema#"
  }
} as const;
const embeddedName = "xcodebuildmcp";
const embeddedDescription = "Build/test Xcode projects via the XcodeBuildMCP MCP server using a local CLI wrapper for pi (no MCP support). Use when the user mentions Xcode, xcodebuild, iOS builds/tests, or XcodeBuildMCP.";
const generatorInfo = "Generated by xcodebuildmcp@0.0.1 â€” https://github.com/steipete/mcporter";
const generatorTools = [
  {
    "name": "build-device",
    "description": "Builds an app for a connected device.",
    "usage": "build-device [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]"
  },
  {
    "name": "clean",
    "description": "Cleans build products with xcodebuild.",
    "usage": "clean [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--platform <platform:macOS|iOS|iOS Simulator|watchOS|watchOS Simulator|tvOS|tvOS Simulator|visionOS|visionOS Simulator>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--platform <platform:macOS|iOS|iOS Simulator|watchOS|watchOS Simulator|tvOS|tvOS Simulator|visionOS|visionOS Simulator>] [--raw <json>]"
  },
  {
    "name": "discover-projs",
    "description": "Scans a directory (defaults to workspace root) to find Xcode project (.xcodeproj) and workspace (.xcworkspace) files.",
    "usage": "discover-projs --workspace-root <workspace-root> [--scan-path <scan-path>] [--max-depth <max-depth:number>] [--raw <json>]",
    "flags": "--workspace-root <workspace-root> [--scan-path <scan-path>] [--max-depth <max-depth:number>] [--raw <json>]"
  },
  {
    "name": "get-app-bundle-id",
    "description": "Extracts the bundle identifier from an app bundle (.app) for any Apple platform (iOS, iPadOS, watchOS, tvOS, visionOS). IMPORTANT: You MUST provide the appPath parameter. Example: get_app_bundle_id({ appPath: '/path/to/your/app.app' })",
    "usage": "get-app-bundle-id --app-path <app-path> [--raw <json>]",
    "flags": "--app-path <app-path> [--raw <json>]"
  },
  {
    "name": "get-device-app-path",
    "description": "Retrieves the built app path for a connected device.",
    "usage": "get-device-app-path [--platform <platform:iOS|watchOS|tvOS|visionOS>] [--raw <json>]",
    "flags": "[--platform <platform:iOS|watchOS|tvOS|visionOS>] [--raw <json>]"
  },
  {
    "name": "install-app-device",
    "description": "Installs an app on a connected device.",
    "usage": "install-app-device --app-path <app-path> [--raw <json>]",
    "flags": "--app-path <app-path> [--raw <json>]"
  },
  {
    "name": "launch-app-device",
    "description": "Launches an app on a connected device.",
    "usage": "launch-app-device --bundle-id <bundle-id> [--raw <json>]",
    "flags": "--bundle-id <bundle-id> [--raw <json>]"
  },
  {
    "name": "list-devices",
    "description": "Lists connected physical Apple devices (iPhone, iPad, Apple Watch, Apple TV, Apple Vision Pro) with their UUIDs, names, and connection status. Use this to discover physical devices for testing.",
    "usage": "list-devices [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "list-schemes",
    "description": "Lists schemes for a project or workspace.",
    "usage": "list-schemes [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "show-build-settings",
    "description": "Shows xcodebuild build settings.",
    "usage": "show-build-settings [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "start-device-log-cap",
    "description": "Starts log capture on a connected device.",
    "usage": "start-device-log-cap --bundle-id <bundle-id> [--raw <json>]",
    "flags": "--bundle-id <bundle-id> [--raw <json>]"
  },
  {
    "name": "stop-app-device",
    "description": "Stops a running app on a connected device.",
    "usage": "stop-app-device --process-id <process-id:number> [--raw <json>]",
    "flags": "--process-id <process-id:number> [--raw <json>]"
  },
  {
    "name": "stop-device-log-cap",
    "description": "Stops an active Apple device log capture session and returns the captured logs.",
    "usage": "stop-device-log-cap --log-session-id <log-session-id> [--raw <json>]",
    "flags": "--log-session-id <log-session-id> [--raw <json>]"
  },
  {
    "name": "test-device",
    "description": "Runs tests on a physical Apple device.",
    "usage": "test-device [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--platform <platform:iOS|watchOS|tvOS|visionOS>] [--test-runner-env <test-runner-env>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--platform <platform:iOS|watchOS|tvOS|visionOS>] [--test-runner-env <test-runner-env>] [--raw <json>]"
  },
  {
    "name": "doctor",
    "description": "Provides comprehensive information about the MCP server environment, available dependencies, and configuration status.",
    "usage": "doctor [--enabled <enabled:true|false>] [--raw <json>]",
    "flags": "[--enabled <enabled:true|false>] [--raw <json>]"
  },
  {
    "name": "start-sim-log-cap",
    "description": "Starts capturing logs from a specified simulator. Returns a session ID. By default, captures only structured logs.",
    "usage": "start-sim-log-cap --bundle-id <bundle-id> [--capture-console <capture-console:true|false>] [--raw <json>]",
    "flags": "--bundle-id <bundle-id> [--capture-console <capture-console:true|false>] [--raw <json>]"
  },
  {
    "name": "stop-sim-log-cap",
    "description": "Stops an active simulator log capture session and returns the captured logs.",
    "usage": "stop-sim-log-cap --log-session-id <log-session-id> [--raw <json>]",
    "flags": "--log-session-id <log-session-id> [--raw <json>]"
  },
  {
    "name": "build-macos",
    "description": "Builds a macOS app.",
    "usage": "build-macos [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]"
  },
  {
    "name": "build-run-macos",
    "description": "Builds and runs a macOS app.",
    "usage": "build-run-macos [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]"
  },
  {
    "name": "get-mac-app-path",
    "description": "Retrieves the built macOS app bundle path.",
    "usage": "get-mac-app-path [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--raw <json>]"
  },
  {
    "name": "get-mac-bundle-id",
    "description": "Extracts the bundle identifier from a macOS app bundle (.app). IMPORTANT: You MUST provide the appPath parameter. Example: get_mac_bundle_id({ appPath: '/path/to/your/app.app' }) Note: In some environments, this tool may be prefixed as mcp0_get_macos_bundle_id.",
    "usage": "get-mac-bundle-id --app-path <app-path> [--raw <json>]",
    "flags": "--app-path <app-path> [--raw <json>]"
  },
  {
    "name": "launch-mac-app",
    "description": "Launches a macOS application. IMPORTANT: You MUST provide the appPath parameter. Example: launch_mac_app({ appPath: '/path/to/your/app.app' }) Note: In some environments, this tool may be prefixed as mcp0_launch_macos_app.",
    "usage": "launch-mac-app --app-path <app-path> [--args <args:value1,value2>] [--raw <json>]",
    "flags": "--app-path <app-path> [--args <args:value1,value2>] [--raw <json>]"
  },
  {
    "name": "stop-mac-app",
    "description": "Stops a running macOS application. Can stop by app name or process ID.",
    "usage": "stop-mac-app [--app-name <app-name>] [--process-id <process-id:number>] [--raw <json>]",
    "flags": "[--app-name <app-name>] [--process-id <process-id:number>] [--raw <json>]"
  },
  {
    "name": "test-macos",
    "description": "Runs tests for a macOS target.",
    "usage": "test-macos [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--test-runner-env <test-runner-env>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--test-runner-env <test-runner-env>] [--raw <json>]"
  },
  {
    "name": "scaffold-ios-project",
    "description": "Scaffold a new iOS project from templates. Creates a modern Xcode project with workspace structure, SPM package for features, and proper iOS configuration.",
    "usage": "scaffold-ios-project --project-name <project-name> --output-path <output-path> [--bundle-identifier <bundle-identifier>] [--display-name <display-name>] [--marketing-version <marketing-version>] [--raw <json>]",
    "flags": "--project-name <project-name> --output-path <output-path> [--bundle-identifier <bundle-identifier>] [--display-name <display-name>] [--marketing-version <marketing-version>] [--raw <json>]"
  },
  {
    "name": "scaffold-macos-project",
    "description": "Scaffold a new macOS project from templates. Creates a modern Xcode project with workspace structure, SPM package for features, and proper macOS configuration.",
    "usage": "scaffold-macos-project --project-name <project-name> --output-path <output-path> [--bundle-identifier <bundle-identifier>] [--display-name <display-name>] [--marketing-version <marketing-version>] [--raw <json>]",
    "flags": "--project-name <project-name> --output-path <output-path> [--bundle-identifier <bundle-identifier>] [--display-name <display-name>] [--marketing-version <marketing-version>] [--raw <json>]"
  },
  {
    "name": "session-clear-defaults",
    "description": "Clear selected or all session defaults.",
    "usage": "session-clear-defaults [--keys <keys:projectPath|workspacePath|scheme|configuration|simulatorName|simulatorId|deviceId|useLatestOS|arch>] [--all <all:true|false>] [--raw <json>]",
    "flags": "[--keys <keys:projectPath|workspacePath|scheme|configuration|simulatorName|simulatorId|deviceId|useLatestOS|arch>] [--all <all:true|false>] [--raw <json>]"
  },
  {
    "name": "session-set-defaults",
    "description": "Set the session defaults needed by many tools. Most tools require one or more session defaults to be set before they can be used. Agents should set all relevant defaults up front in a single call (e.g., project/workspace, scheme, simulator or device ID, useLatestOS) to avoid iterative prompts; only set the keys your workflow needs.",
    "usage": "session-set-defaults [--project-path <project-path>] [--workspace-path <workspace-path>] [--scheme <scheme>] [--configuration <configuration>] [--simulator-name <simulator-name>] [--raw <json>]",
    "flags": "[--project-path <project-path>] [--workspace-path <workspace-path>] [--scheme <scheme>] [--configuration <configuration>] [--simulator-name <simulator-name>] [--raw <json>]"
  },
  {
    "name": "session-show-defaults",
    "description": "Show current session defaults.",
    "usage": "session-show-defaults [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "boot-sim",
    "description": "Boots an iOS simulator.",
    "usage": "boot-sim [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "build-run-sim",
    "description": "Builds and runs an app on an iOS simulator.",
    "usage": "build-run-sim [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]"
  },
  {
    "name": "build-sim",
    "description": "Builds an app for an iOS simulator.",
    "usage": "build-sim [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]"
  },
  {
    "name": "describe-ui",
    "description": "Gets entire view hierarchy with precise frame coordinates (x, y, width, height) for all visible elements. Use this before UI interactions or after layout changes - do NOT guess coordinates from screenshots. Returns JSON tree with frame data for accurate automation.",
    "usage": "describe-ui [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "get-sim-app-path",
    "description": "Retrieves the built app path for an iOS simulator.",
    "usage": "get-sim-app-path --platform <platform:iOS Simulator|watchOS Simulator|tvOS Simulator|visionOS Simulator> [--raw <json>]",
    "flags": "--platform <platform:iOS Simulator|watchOS Simulator|tvOS Simulator|visionOS Simulator> [--raw <json>]"
  },
  {
    "name": "install-app-sim",
    "description": "Installs an app in an iOS simulator.",
    "usage": "install-app-sim --app-path <app-path> [--raw <json>]",
    "flags": "--app-path <app-path> [--raw <json>]"
  },
  {
    "name": "launch-app-logs-sim",
    "description": "Launches an app in an iOS simulator and captures its logs.",
    "usage": "launch-app-logs-sim --bundle-id <bundle-id> [--args <args:value1,value2>] [--raw <json>]",
    "flags": "--bundle-id <bundle-id> [--args <args:value1,value2>] [--raw <json>]"
  },
  {
    "name": "launch-app-sim",
    "description": "Launches an app in an iOS simulator.",
    "usage": "launch-app-sim --bundle-id <bundle-id> [--args <args:value1,value2>] [--raw <json>]",
    "flags": "--bundle-id <bundle-id> [--args <args:value1,value2>] [--raw <json>]"
  },
  {
    "name": "list-sims",
    "description": "Lists available iOS simulators with their UUIDs. ",
    "usage": "list-sims [--enabled <enabled:true|false>] [--raw <json>]",
    "flags": "[--enabled <enabled:true|false>] [--raw <json>]"
  },
  {
    "name": "open-sim",
    "description": "Opens the iOS Simulator app.",
    "usage": "open-sim [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "record-sim-video",
    "description": "Starts or stops video capture for an iOS simulator.",
    "usage": "record-sim-video [--start <start:true|false>] [--stop <stop:true|false>] [--fps <fps:number>] [--output-file <output-file>] [--raw <json>]",
    "flags": "[--start <start:true|false>] [--stop <stop:true|false>] [--fps <fps:number>] [--output-file <output-file>] [--raw <json>]"
  },
  {
    "name": "screenshot",
    "description": "Captures screenshot for visual verification. For UI coordinates, use describe_ui instead (don't determine coordinates from screenshots).",
    "usage": "screenshot [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "stop-app-sim",
    "description": "Stops an app running in an iOS simulator.",
    "usage": "stop-app-sim --bundle-id <bundle-id> [--raw <json>]",
    "flags": "--bundle-id <bundle-id> [--raw <json>]"
  },
  {
    "name": "test-sim",
    "description": "Runs tests on an iOS simulator.",
    "usage": "test-sim [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--test-runner-env <test-runner-env>] [--raw <json>]",
    "flags": "[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--test-runner-env <test-runner-env>] [--raw <json>]"
  },
  {
    "name": "erase-sims",
    "description": "Erases a simulator by UDID.",
    "usage": "erase-sims [--shutdown-first <shutdown-first:true|false>] [--raw <json>]",
    "flags": "[--shutdown-first <shutdown-first:true|false>] [--raw <json>]"
  },
  {
    "name": "reset-sim-location",
    "description": "Resets the simulator's location to default.",
    "usage": "reset-sim-location [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "set-sim-appearance",
    "description": "Sets the appearance mode (dark/light) of an iOS simulator.",
    "usage": "set-sim-appearance --mode <mode:dark|light> [--raw <json>]",
    "flags": "--mode <mode:dark|light> [--raw <json>]"
  },
  {
    "name": "set-sim-location",
    "description": "Sets a custom GPS location for the simulator.",
    "usage": "set-sim-location --latitude <latitude:number> --longitude <longitude:number> [--raw <json>]",
    "flags": "--latitude <latitude:number> --longitude <longitude:number> [--raw <json>]"
  },
  {
    "name": "sim-statusbar",
    "description": "Sets the data network indicator in the iOS simulator status bar. Use \"clear\" to reset all overrides, or specify a network type (hide, wifi, 3g, 4g, lte, lte-a, lte+, 5g, 5g+, 5g-uwb, 5g-uc).",
    "usage": "sim-statusbar --data-network <data-network:clear|hide|wifi|3g|4g|lte|lte-a|lte+|5g|5g+|5g-uwb|5g-uc> [--raw <json>]",
    "flags": "--data-network <data-network:clear|hide|wifi|3g|4g|lte|lte-a|lte+|5g|5g+|5g-uwb|5g-uc> [--raw <json>]"
  },
  {
    "name": "swift-package-build",
    "description": "Builds a Swift Package with swift build",
    "usage": "swift-package-build --package-path <package-path> [--target-name <target-name>] [--configuration <configuration:debug|release>] [--architectures <architectures:value1,value2>] [--parse-as-library <parse-as-library:true|false>] [--raw <json>]",
    "flags": "--package-path <package-path> [--target-name <target-name>] [--configuration <configuration:debug|release>] [--architectures <architectures:value1,value2>] [--parse-as-library <parse-as-library:true|false>] [--raw <json>]"
  },
  {
    "name": "swift-package-clean",
    "description": "Cleans Swift Package build artifacts and derived data",
    "usage": "swift-package-clean --package-path <package-path> [--raw <json>]",
    "flags": "--package-path <package-path> [--raw <json>]"
  },
  {
    "name": "swift-package-list",
    "description": "Lists currently running Swift Package processes",
    "usage": "swift-package-list [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "swift-package-run",
    "description": "Runs an executable target from a Swift Package with swift run",
    "usage": "swift-package-run --package-path <package-path> [--executable-name <executable-name>] [--arguments <arguments:value1,value2>] [--configuration <configuration:debug|release>] [--timeout <timeout:number>] [--raw <json>]",
    "flags": "--package-path <package-path> [--executable-name <executable-name>] [--arguments <arguments:value1,value2>] [--configuration <configuration:debug|release>] [--timeout <timeout:number>] [--raw <json>]"
  },
  {
    "name": "swift-package-stop",
    "description": "Stops a running Swift Package executable started with swift_package_run",
    "usage": "swift-package-stop --pid <pid:number> [--raw <json>]",
    "flags": "--pid <pid:number> [--raw <json>]"
  },
  {
    "name": "swift-package-test",
    "description": "Runs tests for a Swift Package with swift test",
    "usage": "swift-package-test --package-path <package-path> [--test-product <test-product>] [--filter <filter>] [--configuration <configuration:debug|release>] [--parallel <parallel:true|false>] [--raw <json>]",
    "flags": "--package-path <package-path> [--test-product <test-product>] [--filter <filter>] [--configuration <configuration:debug|release>] [--parallel <parallel:true|false>] [--raw <json>]"
  },
  {
    "name": "button",
    "description": "Press hardware button on iOS simulator. Supported buttons: apple-pay, home, lock, side-button, siri",
    "usage": "button --button-type <button-type:apple-pay|home|lock|side-button|siri> [--duration <duration:number>] [--raw <json>]",
    "flags": "--button-type <button-type:apple-pay|home|lock|side-button|siri> [--duration <duration:number>] [--raw <json>]"
  },
  {
    "name": "gesture",
    "description": "Perform gesture on iOS simulator using preset gestures: scroll-up, scroll-down, scroll-left, scroll-right, swipe-from-left-edge, swipe-from-right-edge, swipe-from-top-edge, swipe-from-bottom-edge",
    "usage": "gesture --preset <preset:scroll-up|scroll-down|scroll-left|scroll-right|swipe-from-left-edge|swipe-from-right-edge|swipe-from-top-edge|swipe-from-bottom-edge> [--screen-width <screen-width:number>] [--screen-height <screen-height:number>] [--duration <duration:number>] [--delta <delta:number>] [--raw <json>]",
    "flags": "--preset <preset:scroll-up|scroll-down|scroll-left|scroll-right|swipe-from-left-edge|swipe-from-right-edge|swipe-from-top-edge|swipe-from-bottom-edge> [--screen-width <screen-width:number>] [--screen-height <screen-height:number>] [--duration <duration:number>] [--delta <delta:number>] [--raw <json>]"
  },
  {
    "name": "key-press",
    "description": "Press a single key by keycode on the simulator. Common keycodes: 40=Return, 42=Backspace, 43=Tab, 44=Space, 58-67=F1-F10.",
    "usage": "key-press --key-code <key-code:number> [--duration <duration:number>] [--raw <json>]",
    "flags": "--key-code <key-code:number> [--duration <duration:number>] [--raw <json>]"
  },
  {
    "name": "key-sequence",
    "description": "Press key sequence using HID keycodes on iOS simulator with configurable delay",
    "usage": "key-sequence --key-codes <key-codes:value1,value2> [--delay <delay:number>] [--raw <json>]",
    "flags": "--key-codes <key-codes:value1,value2> [--delay <delay:number>] [--raw <json>]"
  },
  {
    "name": "long-press",
    "description": "Long press at specific coordinates for given duration (ms). Use describe_ui for precise coordinates (don't guess from screenshots).",
    "usage": "long-press --x <x:number> --y <y:number> --duration <duration:number> [--raw <json>]",
    "flags": "--x <x:number> --y <y:number> --duration <duration:number> [--raw <json>]"
  },
  {
    "name": "swipe",
    "description": "Swipe from one point to another. Use describe_ui for precise coordinates (don't guess from screenshots). Supports configurable timing.",
    "usage": "swipe --x1 <x1:number> --y1 <y1:number> --x2 <x2:number> --y2 <y2:number> [--duration <duration:number>] [--raw <json>]",
    "flags": "--x1 <x1:number> --y1 <y1:number> --x2 <x2:number> --y2 <y2:number> [--duration <duration:number>] [--raw <json>]"
  },
  {
    "name": "tap",
    "description": "Tap at specific coordinates or target elements by accessibility id or label. Use describe_ui to get precise element coordinates prior to using x/y parameters (don't guess from screenshots). Supports optional timing delays.",
    "usage": "tap [--x <x:number>] [--y <y:number>] [--id <id>] [--label <label>] [--pre-delay <pre-delay:number>] [--raw <json>]",
    "flags": "[--x <x:number>] [--y <y:number>] [--id <id>] [--label <label>] [--pre-delay <pre-delay:number>] [--raw <json>]"
  },
  {
    "name": "touch",
    "description": "Perform touch down/up events at specific coordinates. Use describe_ui for precise coordinates (don't guess from screenshots).",
    "usage": "touch --x <x:number> --y <y:number> [--down <down:true|false>] [--up <up:true|false>] [--delay <delay:number>] [--raw <json>]",
    "flags": "--x <x:number> --y <y:number> [--down <down:true|false>] [--up <up:true|false>] [--delay <delay:number>] [--raw <json>]"
  },
  {
    "name": "type-text",
    "description": "Type text (supports US keyboard characters). Use describe_ui to find text field, tap to focus, then type.",
    "usage": "type-text --text <text> [--raw <json>]",
    "flags": "--text <text> [--raw <json>]"
  }
] as const;
const embeddedMetadata = {
  "schemaVersion": 1,
  "generatedAt": "2026-01-17T01:54:17.146Z",
  "generator": {
    "name": "xcodebuildmcp",
    "version": "0.0.1"
  },
  "server": {
    "name": "xcodebuildmcp",
    "source": {
      "kind": "local",
      "path": "<adhoc>"
    },
    "definition": {
      "name": "xcodebuildmcp",
      "description": "Build/test Xcode projects via the XcodeBuildMCP MCP server using a local CLI wrapper for pi (no MCP support). Use when the user mentions Xcode, xcodebuild, iOS builds/tests, or XcodeBuildMCP.",
      "command": {
        "kind": "stdio",
        "command": "npx",
        "args": [
          "-y",
          "xcodebuildmcp@latest"
        ]
      }
    }
  },
  "artifact": {
    "path": "",
    "kind": "template"
  },
  "invocation": {
    "serverRef": "{\"name\":\"xcodebuildmcp\",\"description\":\"Build/test Xcode projects via the XcodeBuildMCP MCP server using a local CLI wrapper for pi (no MCP support). Use when the user mentions Xcode, xcodebuild, iOS builds/tests, or XcodeBuildMCP.\",\"command\":{\"kind\":\"stdio\",\"command\":\"npx\",\"args\":[\"-y\",\"xcodebuildmcp@latest\"]},\"source\":{\"kind\":\"local\",\"path\":\"<adhoc>\"}}",
    "configPath": "<adhoc>",
    "runtime": "node",
    "bundler": "rolldown",
    "outputPath": "/Users/ww/.pi/agent/skills/xcodebuildmcp/xcodebuildmcp.ts",
    "timeoutMs": 30000,
    "minify": false
  }
} as const;
const artifactKind = determineArtifactKind();
const program = new Command();
program.name(embeddedName);
program.description(embeddedDescription);
program.option('-t, --timeout <ms>', 'Call timeout in milliseconds', (value) => parseInt(value, 10), 30000);
program.option('-o, --output <format>', 'Output format: text|markdown|json|raw', 'text');
const commandSignatures: Record<string, string> = {
  "build-device": "function build_device(derivedDataPath?: string, extraArgs?: string[], preferXcodebuild?: boolean);",
  "clean": "function clean(derivedDataPath?: string, extraArgs?: string[], preferXcodebuild?: boolean, platform?: \"macOS\" | \"iOS\" | \"iOS Simulator\" | \"watchOS\" | \"watchOS Simulator\" | \"tvOS\" | \"tvOS Simulator\" | \"visionOS\" | \"visionOS Simulator\");",
  "discover-projs": "function discover_projs(workspaceRoot: string, scanPath?: string, maxDepth?: number);",
  "get-app-bundle-id": "function get_app_bundle_id(appPath: string);",
  "get-device-app-path": "function get_device_app_path(platform?: \"iOS\" | \"watchOS\" | \"tvOS\" | \"visionOS\");",
  "install-app-device": "function install_app_device(appPath: string);",
  "launch-app-device": "function launch_app_device(bundleId: string);",
  "list-devices": "function list_devices();",
  "list-schemes": "function list_schemes();",
  "show-build-settings": "function show_build_settings();",
  "start-device-log-cap": "function start_device_log_cap(bundleId: string);",
  "stop-app-device": "function stop_app_device(processId: number);",
  "stop-device-log-cap": "function stop_device_log_cap(logSessionId: string);",
  "test-device": "function test_device(derivedDataPath?: string, extraArgs?: string[], preferXcodebuild?: boolean, platform?: \"iOS\" | \"watchOS\" | \"tvOS\" | \"visionOS\", testRunnerEnv?: unknown);",
  "doctor": "function doctor(enabled?: boolean);",
  "start-sim-log-cap": "function start_sim_log_cap(bundleId: string, captureConsole?: boolean);",
  "stop-sim-log-cap": "function stop_sim_log_cap(logSessionId: string);",
  "build-macos": "function build_macos(derivedDataPath?: string, extraArgs?: string[], preferXcodebuild?: boolean);",
  "build-run-macos": "function build_run_macos(derivedDataPath?: string, extraArgs?: string[], preferXcodebuild?: boolean);",
  "get-mac-app-path": "function get_mac_app_path(derivedDataPath?: string, extraArgs?: string[]);",
  "get-mac-bundle-id": "function get_mac_bundle_id(appPath: string);",
  "launch-mac-app": "function launch_mac_app(appPath: string, args?: string[]);",
  "stop-mac-app": "function stop_mac_app(appName?: string, processId?: number);",
  "test-macos": "function test_macos(derivedDataPath?: string, extraArgs?: string[], preferXcodebuild?: boolean, testRunnerEnv?: unknown);",
  "scaffold-ios-project": "function scaffold_ios_project(projectName: string, outputPath: string, bundleIdentifier?: string, displayName?: string, marketingVersion?: string);",
  "scaffold-macos-project": "function scaffold_macos_project(projectName: string, outputPath: string, bundleIdentifier?: string, displayName?: string, marketingVersion?: string);",
  "session-clear-defaults": "function session-clear-defaults(keys?: \"projectPath\" | \"workspacePath\" | \"scheme\" | \"configuration\" | \"simulatorName\" | \"simulatorId\" | \"deviceId\" | \"useLatestOS\" | \"arch\", all?: boolean);",
  "session-set-defaults": "function session-set-defaults(projectPath?: string, workspacePath?: string, scheme?: string, configuration?: string, simulatorName?: string);",
  "session-show-defaults": "function session-show-defaults();",
  "boot-sim": "function boot_sim();",
  "build-run-sim": "function build_run_sim(derivedDataPath?: string, extraArgs?: string[], preferXcodebuild?: boolean);",
  "build-sim": "function build_sim(derivedDataPath?: string, extraArgs?: string[], preferXcodebuild?: boolean);",
  "describe-ui": "function describe_ui();",
  "get-sim-app-path": "function get_sim_app_path(platform: \"iOS Simulator\" | \"watchOS Simulator\" | \"tvOS Simulator\" | \"visionOS Simulator\");",
  "install-app-sim": "function install_app_sim(appPath: string);",
  "launch-app-logs-sim": "function launch_app_logs_sim(bundleId: string, args?: string[]);",
  "launch-app-sim": "function launch_app_sim(bundleId: string, args?: string[]);",
  "list-sims": "function list_sims(enabled?: boolean);",
  "open-sim": "function open_sim();",
  "record-sim-video": "function record_sim_video(start?: boolean, stop?: boolean, fps?: number, outputFile?: string);",
  "screenshot": "function screenshot();",
  "stop-app-sim": "function stop_app_sim(bundleId: string);",
  "test-sim": "function test_sim(derivedDataPath?: string, extraArgs?: string[], preferXcodebuild?: boolean, testRunnerEnv?: unknown);",
  "erase-sims": "function erase_sims(shutdownFirst?: boolean);",
  "reset-sim-location": "function reset_sim_location();",
  "set-sim-appearance": "function set_sim_appearance(mode: \"dark\" | \"light\");",
  "set-sim-location": "function set_sim_location(latitude: number, longitude: number);",
  "sim-statusbar": "function sim_statusbar(dataNetwork: \"clear\" | \"hide\" | \"wifi\" | \"3g\" | \"4g\" | \"lte\" | \"lte-a\" | \"lte+\" | \"5g\" | \"5g+\" | \"5g-uwb\" | \"5g-uc\");",
  "swift-package-build": "function swift_package_build(packagePath: string, targetName?: string, configuration?: \"debug\" | \"release\", architectures?: string[], parseAsLibrary?: boolean);",
  "swift-package-clean": "function swift_package_clean(packagePath: string);",
  "swift-package-list": "function swift_package_list();",
  "swift-package-run": "function swift_package_run(packagePath: string, executableName?: string, arguments?: string[], configuration?: \"debug\" | \"release\", timeout?: number);",
  "swift-package-stop": "function swift_package_stop(pid: number);",
  "swift-package-test": "function swift_package_test(packagePath: string, testProduct?: string, filter?: string, configuration?: \"debug\" | \"release\", parallel?: boolean);",
  "button": "function button(buttonType: \"apple-pay\" | \"home\" | \"lock\" | \"side-button\" | \"siri\", duration?: number);",
  "gesture": "function gesture(preset: \"scroll-up\" | \"scroll-down\" | \"scroll-left\" | \"scroll-right\" | \"swipe-from-left-edge\" | \"swipe-from-right-edge\" | \"swipe-from-top-edge\" | \"swipe-from-bottom-edge\", screenWidth?: number, screenHeight?: number, duration?: number, delta?: number);",
  "key-press": "function key_press(keyCode: number, duration?: number);",
  "key-sequence": "function key_sequence(keyCodes: string[], delay?: number);",
  "long-press": "function long_press(x: number, y: number, duration: number);",
  "swipe": "function swipe(x1: number, y1: number, x2: number, y2: number, duration?: number);",
  "tap": "function tap(x?: number, y?: number, id?: string, label?: string, preDelay?: number);",
  "touch": "function touch(x: number, y: number, down?: boolean, up?: boolean, delay?: number);",
  "type-text": "function type_text(text: string);"
};
program.configureHelp({
	commandTerm(cmd) {
		const term = cmd.name();
		return commandSignatures[term] ?? cmd.name();
	},
});
program.showSuggestionAfterError(true);

program
	.command("build-device")
	.summary("build-device [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.description("Builds an app for a connected device.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Path to derived data directory (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional arguments to pass to xcodebuild (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--prefer-xcodebuild <prefer-xcodebuild:true|false>", "Prefer xcodebuild over faster alternatives (example: true)", (value) => value !== 'false')
	
	.alias("build_device")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
		if (cmdOpts.preferXcodebuild !== undefined) args.preferXcodebuild = cmdOpts.preferXcodebuild;
			const call = (proxy.buildDevice as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.build_device(derivedDataPath: \"/path/to/file.m, ...)");

program
	.command("clean")
	.summary("clean [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--platform <platform:macOS|iOS|iOS Simulator|watchOS|watchOS Simulator|tvOS|tvOS Simulator|visionOS|visionOS Simulator>] [--raw <json>]")
	.description("Cleans build products with xcodebuild.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--platform <platform:macOS|iOS|iOS Simulator|watchOS|watchOS Simulator|tvOS|tvOS Simulator|visionOS|visionOS Simulator>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Optional: Path where derived data might be located (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional xcodebuild arguments (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--prefer-xcodebuild <prefer-xcodebuild:true|false>", "If true, prefers xcodebuild over the experimental incremental build system, useful for when incremental build system fails. (example: true)", (value) => value !== 'false')
	.option("--platform <platform:macOS|iOS|iOS Simulator|watchOS|watchOS Simulator|tvOS|tvOS Simulator|visionOS|visionOS Simulator>", "Optional: Platform to clean for (defaults to iOS). Choose from macOS, iOS, iOS Simulator, watchOS, watchOS Simulator, tvOS, tvOS Simulator, visionOS, visionOS Simulator (choices: macOS, iOS, iOS Simulator, watchOS, watchOS Simulator, tvOS, tvOS Simulator, visionOS, visionOS Simulator; example: macOS)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
		if (cmdOpts.preferXcodebuild !== undefined) args.preferXcodebuild = cmdOpts.preferXcodebuild;
		if (cmdOpts.platform !== undefined) args.platform = cmdOpts.platform;
			const call = (proxy.clean as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.clean(derivedDataPath: \"/path/to/file.md\", ext, ...)");

program
	.command("discover-projs")
	.summary("discover-projs --workspace-root <workspace-root> [--scan-path <scan-path>] [--max-depth <max-depth:number>] [--raw <json>]")
	.description("Scans a directory (defaults to workspace root) to find Xcode project (.xcodeproj) and workspace (.xcworkspace) files.")
	.usage("--workspace-root <workspace-root> [--scan-path <scan-path>] [--max-depth <max-depth:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--workspace-root <workspace-root>", "The absolute path of the workspace root to scan within.")
	.option("--scan-path <scan-path>", "Optional: Path relative to workspace root to scan. Defaults to workspace root. (example: /path/to/file.md)")
	.option("--max-depth <max-depth:number>", "Optional: Maximum directory depth to scan. Defaults to 5. (example: 1)", (value) => parseFloat(value))
	
	.alias("discover_projs")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.workspaceRoot !== undefined) args.workspaceRoot = cmdOpts.workspaceRoot;
		if (cmdOpts.scanPath !== undefined) args.scanPath = cmdOpts.scanPath;
		if (cmdOpts.maxDepth !== undefined) args.maxDepth = cmdOpts.maxDepth;
			const call = (proxy.discoverProjs as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.discover_projs(workspaceRoot: \"value\", scanPat, ...)");

program
	.command("get-app-bundle-id")
	.summary("get-app-bundle-id --app-path <app-path> [--raw <json>]")
	.description("Extracts the bundle identifier from an app bundle (.app) for any Apple platform (iOS, iPadOS, watchOS, tvOS, visionOS). IMPORTANT: You MUST provide the appPath parameter. Example: get_app_bundle_id({ appPath: '/path/to/your/app.app' })")
	.usage("--app-path <app-path> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--app-path <app-path>", "Path to the .app bundle to extract bundle ID from (full path to the .app directory) (example: /path/to/file.md)")
	
	.alias("get_app_bundle_id")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.appPath !== undefined) args.appPath = cmdOpts.appPath;
			const call = (proxy.getAppBundleId as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.get_app_bundle_id(appPath: \"/path/to/file.md\")");

program
	.command("get-device-app-path")
	.summary("get-device-app-path [--platform <platform:iOS|watchOS|tvOS|visionOS>] [--raw <json>]")
	.description("Retrieves the built app path for a connected device.")
	.usage("[--platform <platform:iOS|watchOS|tvOS|visionOS>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--platform <platform:iOS|watchOS|tvOS|visionOS>", "Target platform (defaults to iOS) (choices: iOS, watchOS, tvOS, visionOS; example: iOS)")
	
	.alias("get_device_app_path")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.platform !== undefined) args.platform = cmdOpts.platform;
			const call = (proxy.getDeviceAppPath as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.get_device_app_path(platform: \"iOS\")");

program
	.command("install-app-device")
	.summary("install-app-device --app-path <app-path> [--raw <json>]")
	.description("Installs an app on a connected device.")
	.usage("--app-path <app-path> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--app-path <app-path>", "Path to the .app bundle to install (full path to the .app directory) (example: /path/to/file.md)")
	
	.alias("install_app_device")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.appPath !== undefined) args.appPath = cmdOpts.appPath;
			const call = (proxy.installAppDevice as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.install_app_device(appPath: \"/path/to/file.md\")");

program
	.command("launch-app-device")
	.summary("launch-app-device --bundle-id <bundle-id> [--raw <json>]")
	.description("Launches an app on a connected device.")
	.usage("--bundle-id <bundle-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--bundle-id <bundle-id>", "Bundle identifier of the app to launch (e.g., \"com.example.MyApp\") (example: example-id)")
	
	.alias("launch_app_device")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.bundleId !== undefined) args.bundleId = cmdOpts.bundleId;
			const call = (proxy.launchAppDevice as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.launch_app_device(bundleId: \"example-id\")");

program
	.command("list-devices")
	.summary("list-devices [--raw <json>]")
	.description("Lists connected physical Apple devices (iPhone, iPad, Apple Watch, Apple TV, Apple Vision Pro) with their UUIDs, names, and connection status. Use this to discover physical devices for testing.")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("list_devices")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.listDevices as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.list_devices()");

program
	.command("list-schemes")
	.summary("list-schemes [--raw <json>]")
	.description("Lists schemes for a project or workspace.")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("list_schemes")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.listSchemes as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.list_schemes()");

program
	.command("show-build-settings")
	.summary("show-build-settings [--raw <json>]")
	.description("Shows xcodebuild build settings.")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("show_build_settings")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.showBuildSettings as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.show_build_settings()");

program
	.command("start-device-log-cap")
	.summary("start-device-log-cap --bundle-id <bundle-id> [--raw <json>]")
	.description("Starts log capture on a connected device.")
	.usage("--bundle-id <bundle-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--bundle-id <bundle-id>", "Bundle identifier of the app to launch and capture logs for. (example: example-id)")
	
	.alias("start_device_log_cap")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.bundleId !== undefined) args.bundleId = cmdOpts.bundleId;
			const call = (proxy.startDeviceLogCap as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.start_device_log_cap(bundleId: \"example-id\")");

program
	.command("stop-app-device")
	.summary("stop-app-device --process-id <process-id:number> [--raw <json>]")
	.description("Stops a running app on a connected device.")
	.usage("--process-id <process-id:number> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--process-id <process-id:number>", "Process ID (PID) of the app to stop (example: 1)", (value) => parseFloat(value))
	
	.alias("stop_app_device")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.processId !== undefined) args.processId = cmdOpts.processId;
			const call = (proxy.stopAppDevice as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.stop_app_device(processId: 1)");

program
	.command("stop-device-log-cap")
	.summary("stop-device-log-cap --log-session-id <log-session-id> [--raw <json>]")
	.description("Stops an active Apple device log capture session and returns the captured logs.")
	.usage("--log-session-id <log-session-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--log-session-id <log-session-id>", "The session ID returned by start_device_log_cap. (example: example-id)")
	
	.alias("stop_device_log_cap")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.logSessionId !== undefined) args.logSessionId = cmdOpts.logSessionId;
			const call = (proxy.stopDeviceLogCap as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.stop_device_log_cap(logSessionId: \"example-id\")");

program
	.command("test-device")
	.summary("test-device [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--platform <platform:iOS|watchOS|tvOS|visionOS>] [--test-runner-env <test-runner-env>] [--raw <json>]")
	.description("Runs tests on a physical Apple device.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--platform <platform:iOS|watchOS|tvOS|visionOS>] [--test-runner-env <test-runner-env>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Path to derived data directory (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional arguments to pass to xcodebuild (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--prefer-xcodebuild <prefer-xcodebuild:true|false>", "Prefer xcodebuild over faster alternatives (example: true)", (value) => value !== 'false')
	.option("--platform <platform:iOS|watchOS|tvOS|visionOS>", "Target platform (defaults to iOS) (choices: iOS, watchOS, tvOS, visionOS; example: iOS)")
	.option("--test-runner-env <test-runner-env>", "Environment variables to pass to the test runner (TEST_RUNNER_ prefix added automatically)")
	
	.alias("test_device")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
		if (cmdOpts.preferXcodebuild !== undefined) args.preferXcodebuild = cmdOpts.preferXcodebuild;
		if (cmdOpts.platform !== undefined) args.platform = cmdOpts.platform;
		if (cmdOpts.testRunnerEnv !== undefined) args.testRunnerEnv = cmdOpts.testRunnerEnv;
			const call = (proxy.testDevice as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.test_device(derivedDataPath: \"/path/to/file.md, ...)");

program
	.command("doctor")
	.summary("doctor [--enabled <enabled:true|false>] [--raw <json>]")
	.description("Provides comprehensive information about the MCP server environment, available dependencies, and configuration status.")
	.usage("[--enabled <enabled:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--enabled <enabled:true|false>", "Optional: dummy parameter to satisfy MCP protocol (example: true)", (value) => value !== 'false')
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.enabled !== undefined) args.enabled = cmdOpts.enabled;
			const call = (proxy.doctor as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.doctor(enabled: true)");

program
	.command("start-sim-log-cap")
	.summary("start-sim-log-cap --bundle-id <bundle-id> [--capture-console <capture-console:true|false>] [--raw <json>]")
	.description("Starts capturing logs from a specified simulator. Returns a session ID. By default, captures only structured logs.")
	.usage("--bundle-id <bundle-id> [--capture-console <capture-console:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--bundle-id <bundle-id>", "Bundle identifier of the app to capture logs for. (example: example-id)")
	.option("--capture-console <capture-console:true|false>", "Whether to capture console output (requires app relaunch). (example: true)", (value) => value !== 'false')
	
	.alias("start_sim_log_cap")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.bundleId !== undefined) args.bundleId = cmdOpts.bundleId;
		if (cmdOpts.captureConsole !== undefined) args.captureConsole = cmdOpts.captureConsole;
			const call = (proxy.startSimLogCap as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.start_sim_log_cap(bundleId: \"example-id\", capt, ...)");

program
	.command("stop-sim-log-cap")
	.summary("stop-sim-log-cap --log-session-id <log-session-id> [--raw <json>]")
	.description("Stops an active simulator log capture session and returns the captured logs.")
	.usage("--log-session-id <log-session-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--log-session-id <log-session-id>", "The session ID returned by start_sim_log_cap. (example: example-id)")
	
	.alias("stop_sim_log_cap")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.logSessionId !== undefined) args.logSessionId = cmdOpts.logSessionId;
			const call = (proxy.stopSimLogCap as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.stop_sim_log_cap(logSessionId: \"example-id\")");

program
	.command("build-macos")
	.summary("build-macos [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.description("Builds a macOS app.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Path where build products and other derived data will go (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional xcodebuild arguments (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--prefer-xcodebuild <prefer-xcodebuild:true|false>", "If true, prefers xcodebuild over the experimental incremental build system (example: true)", (value) => value !== 'false')
	
	.alias("build_macos")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
		if (cmdOpts.preferXcodebuild !== undefined) args.preferXcodebuild = cmdOpts.preferXcodebuild;
			const call = (proxy.buildMacos as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.build_macos(derivedDataPath: \"/path/to/file.md, ...)");

program
	.command("build-run-macos")
	.summary("build-run-macos [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.description("Builds and runs a macOS app.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Path where build products and other derived data will go (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional xcodebuild arguments (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--prefer-xcodebuild <prefer-xcodebuild:true|false>", "If true, prefers xcodebuild over the experimental incremental build system (example: true)", (value) => value !== 'false')
	
	.alias("build_run_macos")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
		if (cmdOpts.preferXcodebuild !== undefined) args.preferXcodebuild = cmdOpts.preferXcodebuild;
			const call = (proxy.buildRunMacos as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.build_run_macos(derivedDataPath: \"/path/to/fil, ...)");

program
	.command("get-mac-app-path")
	.summary("get-mac-app-path [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--raw <json>]")
	.description("Retrieves the built macOS app bundle path.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Path to derived data directory (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional arguments to pass to xcodebuild (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	
	.alias("get_mac_app_path")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
			const call = (proxy.getMacAppPath as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.get_mac_app_path(derivedDataPath: \"/path/to/fi, ...)");

program
	.command("get-mac-bundle-id")
	.summary("get-mac-bundle-id --app-path <app-path> [--raw <json>]")
	.description("Extracts the bundle identifier from a macOS app bundle (.app). IMPORTANT: You MUST provide the appPath parameter. Example: get_mac_bundle_id({ appPath: '/path/to/your/app.app' }) Note: In some environments, this tool may be prefixed as mcp0_get_macos_bundle_id.")
	.usage("--app-path <app-path> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--app-path <app-path>", "Path to the macOS .app bundle to extract bundle ID from (full path to the .app directory) (example: /path/to/file.md)")
	
	.alias("get_mac_bundle_id")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.appPath !== undefined) args.appPath = cmdOpts.appPath;
			const call = (proxy.getMacBundleId as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.get_mac_bundle_id(appPath: \"/path/to/file.md\")");

program
	.command("launch-mac-app")
	.summary("launch-mac-app --app-path <app-path> [--args <args:value1,value2>] [--raw <json>]")
	.description("Launches a macOS application. IMPORTANT: You MUST provide the appPath parameter. Example: launch_mac_app({ appPath: '/path/to/your/app.app' }) Note: In some environments, this tool may be prefixed as mcp0_launch_macos_app.")
	.usage("--app-path <app-path> [--args <args:value1,value2>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--app-path <app-path>", "Path to the macOS .app bundle to launch (full path to the .app directory) (example: /path/to/file.md)")
	.option("--args <args:value1,value2>", "Additional arguments to pass to the app (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	
	.alias("launch_mac_app")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.appPath !== undefined) args.appPath = cmdOpts.appPath;
		if (cmdOpts.args !== undefined) args.args = cmdOpts.args;
			const call = (proxy.launchMacApp as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.launch_mac_app(appPath: \"/path/to/file.md\", ar, ...)");

program
	.command("stop-mac-app")
	.summary("stop-mac-app [--app-name <app-name>] [--process-id <process-id:number>] [--raw <json>]")
	.description("Stops a running macOS application. Can stop by app name or process ID.")
	.usage("[--app-name <app-name>] [--process-id <process-id:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--app-name <app-name>", "Name of the application to stop (e.g., \"Calculator\" or \"MyApp\")")
	.option("--process-id <process-id:number>", "Process ID (PID) of the application to stop (example: 1)", (value) => parseFloat(value))
	
	.alias("stop_mac_app")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.appName !== undefined) args.appName = cmdOpts.appName;
		if (cmdOpts.processId !== undefined) args.processId = cmdOpts.processId;
			const call = (proxy.stopMacApp as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.stop_mac_app(processId: 1)");

program
	.command("test-macos")
	.summary("test-macos [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--test-runner-env <test-runner-env>] [--raw <json>]")
	.description("Runs tests for a macOS target.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--test-runner-env <test-runner-env>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Path where build products and other derived data will go (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional xcodebuild arguments (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--prefer-xcodebuild <prefer-xcodebuild:true|false>", "If true, prefers xcodebuild over the experimental incremental build system (example: true)", (value) => value !== 'false')
	.option("--test-runner-env <test-runner-env>", "Environment variables to pass to the test runner (TEST_RUNNER_ prefix added automatically)")
	
	.alias("test_macos")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
		if (cmdOpts.preferXcodebuild !== undefined) args.preferXcodebuild = cmdOpts.preferXcodebuild;
		if (cmdOpts.testRunnerEnv !== undefined) args.testRunnerEnv = cmdOpts.testRunnerEnv;
			const call = (proxy.testMacos as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.test_macos(derivedDataPath: \"/path/to/file.md\", ...)");

program
	.command("scaffold-ios-project")
	.summary("scaffold-ios-project --project-name <project-name> --output-path <output-path> [--bundle-identifier <bundle-identifier>] [--display-name <display-name>] [--marketing-version <marketing-version>] [--raw <json>]")
	.description("Scaffold a new iOS project from templates. Creates a modern Xcode project with workspace structure, SPM package for features, and proper iOS configuration.")
	.usage("--project-name <project-name> --output-path <output-path> [--bundle-identifier <bundle-identifier>] [--display-name <display-name>] [--marketing-version <marketing-version>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-name <project-name>", "Name of the new project")
	.requiredOption("--output-path <output-path>", "Path where the project should be created (example: /path/to/file.md)")
	.option("--bundle-identifier <bundle-identifier>", "Bundle identifier (e.g., com.example.myapp). If not provided, will use com.example.projectname (example: example-id)")
	.option("--display-name <display-name>", "App display name (shown on home screen/dock). If not provided, will use projectName")
	.option("--marketing-version <marketing-version>", "Marketing version (e.g., 1.0, 2.1.3). If not provided, will use 1.0")
	.option("--current-project-version <current-project-version>", "Build number (e.g., 1, 42, 100). If not provided, will use 1")
	.option("--customize-names <customize-names:true|false>", "Whether to customize project names and identifiers. Default is true. (default: true; example: true)", (value) => value !== 'false')
	.option("--deployment-target <deployment-target>", "iOS deployment target (e.g., 18.4, 17.0). If not provided, will use 18.4")
	.option("--targeted-device-family <targeted-device-family:iphone|ipad|universal>", "Targeted device families (choices: iphone, ipad, universal; example: iphone)", (value) => value.split(',').map((v) => v.trim()))
	.option("--supported-orientations <supported-orientations:portrait|landscape-left|landscape-right|portrait-upside-down>", "Supported orientations for iPhone (choices: portrait, landscape-left, landscape-right, portrait-upside-down; example: portrait)", (value) => value.split(',').map((v) => v.trim()))
	.option("--supported-orientations-ipad <supported-orientations-ipad:portrait|landscape-left|landscape-right|portrait-upside-down>", "Supported orientations for iPad (choices: portrait, landscape-left, landscape-right, portrait-upside-down; example: portrait)", (value) => value.split(',').map((v) => v.trim()))
	
	.alias("scaffold_ios_project")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectName !== undefined) args.projectName = cmdOpts.projectName;
		if (cmdOpts.outputPath !== undefined) args.outputPath = cmdOpts.outputPath;
		if (cmdOpts.bundleIdentifier !== undefined) args.bundleIdentifier = cmdOpts.bundleIdentifier;
		if (cmdOpts.displayName !== undefined) args.displayName = cmdOpts.displayName;
		if (cmdOpts.marketingVersion !== undefined) args.marketingVersion = cmdOpts.marketingVersion;
		if (cmdOpts.currentProjectVersion !== undefined) args.currentProjectVersion = cmdOpts.currentProjectVersion;
		if (cmdOpts.customizeNames !== undefined) args.customizeNames = cmdOpts.customizeNames;
		if (cmdOpts.deploymentTarget !== undefined) args.deploymentTarget = cmdOpts.deploymentTarget;
		if (cmdOpts.targetedDeviceFamily !== undefined) args.targetedDeviceFamily = cmdOpts.targetedDeviceFamily;
		if (cmdOpts.supportedOrientations !== undefined) args.supportedOrientations = cmdOpts.supportedOrientations;
		if (cmdOpts.supportedOrientationsIpad !== undefined) args.supportedOrientationsIpad = cmdOpts.supportedOrientationsIpad;
			const call = (proxy.scaffoldIosProject as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.scaffold_ios_project(projectName: \"value\", out, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (6): currentProjectVersion, customizeNames, deploymentTarget, targetedDeviceFamily, supportedOrientations, ..." + '\n');

program
	.command("scaffold-macos-project")
	.summary("scaffold-macos-project --project-name <project-name> --output-path <output-path> [--bundle-identifier <bundle-identifier>] [--display-name <display-name>] [--marketing-version <marketing-version>] [--raw <json>]")
	.description("Scaffold a new macOS project from templates. Creates a modern Xcode project with workspace structure, SPM package for features, and proper macOS configuration.")
	.usage("--project-name <project-name> --output-path <output-path> [--bundle-identifier <bundle-identifier>] [--display-name <display-name>] [--marketing-version <marketing-version>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-name <project-name>", "Name of the new project")
	.requiredOption("--output-path <output-path>", "Path where the project should be created (example: /path/to/file.md)")
	.option("--bundle-identifier <bundle-identifier>", "Bundle identifier (e.g., com.example.myapp). If not provided, will use com.example.projectname (example: example-id)")
	.option("--display-name <display-name>", "App display name (shown on home screen/dock). If not provided, will use projectName")
	.option("--marketing-version <marketing-version>", "Marketing version (e.g., 1.0, 2.1.3). If not provided, will use 1.0")
	.option("--current-project-version <current-project-version>", "Build number (e.g., 1, 42, 100). If not provided, will use 1")
	.option("--customize-names <customize-names:true|false>", "Whether to customize project names and identifiers. Default is true. (default: true; example: true)", (value) => value !== 'false')
	.option("--deployment-target <deployment-target>", "macOS deployment target (e.g., 15.4, 14.0). If not provided, will use 15.4")
	
	.alias("scaffold_macos_project")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectName !== undefined) args.projectName = cmdOpts.projectName;
		if (cmdOpts.outputPath !== undefined) args.outputPath = cmdOpts.outputPath;
		if (cmdOpts.bundleIdentifier !== undefined) args.bundleIdentifier = cmdOpts.bundleIdentifier;
		if (cmdOpts.displayName !== undefined) args.displayName = cmdOpts.displayName;
		if (cmdOpts.marketingVersion !== undefined) args.marketingVersion = cmdOpts.marketingVersion;
		if (cmdOpts.currentProjectVersion !== undefined) args.currentProjectVersion = cmdOpts.currentProjectVersion;
		if (cmdOpts.customizeNames !== undefined) args.customizeNames = cmdOpts.customizeNames;
		if (cmdOpts.deploymentTarget !== undefined) args.deploymentTarget = cmdOpts.deploymentTarget;
			const call = (proxy.scaffoldMacosProject as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.scaffold_macos_project(projectName: \"value\", o, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (3): currentProjectVersion, customizeNames, deploymentTarget" + '\n');

program
	.command("session-clear-defaults")
	.summary("session-clear-defaults [--keys <keys:projectPath|workspacePath|scheme|configuration|simulatorName|simulatorId|deviceId|useLatestOS|arch>] [--all <all:true|false>] [--raw <json>]")
	.description("Clear selected or all session defaults.")
	.usage("[--keys <keys:projectPath|workspacePath|scheme|configuration|simulatorName|simulatorId|deviceId|useLatestOS|arch>] [--all <all:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--keys <keys:projectPath|workspacePath|scheme|configuration|simulatorName|simulatorId|deviceId|useLatestOS|arch>", "Set keys. (choices: projectPath, workspacePath, scheme, configuration, simulatorName, simulatorId, deviceId, useLatestOS, arch; example: projectPath)", (value) => value.split(',').map((v) => v.trim()))
	.option("--all <all:true|false>", "Set all. (example: true)", (value) => value !== 'false')
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.keys !== undefined) args.keys = cmdOpts.keys;
		if (cmdOpts.all !== undefined) args.all = cmdOpts.all;
			const call = (proxy.sessionClearDefaults as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.session-clear-defaults(keys: \"projectPath\", al, ...)");

program
	.command("session-set-defaults")
	.summary("session-set-defaults [--project-path <project-path>] [--workspace-path <workspace-path>] [--scheme <scheme>] [--configuration <configuration>] [--simulator-name <simulator-name>] [--raw <json>]")
	.description("Set the session defaults needed by many tools. Most tools require one or more session defaults to be set before they can be used. Agents should set all relevant defaults up front in a single call (e.g., project/workspace, scheme, simulator or device ID, useLatestOS) to avoid iterative prompts; only set the keys your workflow needs.")
	.usage("[--project-path <project-path>] [--workspace-path <workspace-path>] [--scheme <scheme>] [--configuration <configuration>] [--simulator-name <simulator-name>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--project-path <project-path>", "Set projectPath. (example: /path/to/file.md)")
	.option("--workspace-path <workspace-path>", "Set workspacePath. (example: /path/to/file.md)")
	.option("--scheme <scheme>", "Set scheme.")
	.option("--configuration <configuration>", "Set configuration.")
	.option("--simulator-name <simulator-name>", "Set simulatorName.")
	.option("--simulator-id <simulator-id>", "Set simulatorId. (example: example-id)")
	.option("--device-id <device-id>", "Set deviceId. (example: example-id)")
	.option("--use-latest-o-s <use-latest-o-s:true|false>", "Set useLatestOS. (example: true)", (value) => value !== 'false')
	.option("--arch <arch:arm64|x86_64>", "Set arch. (choices: arm64, x86_64; example: arm64)")
	.option("--suppress-warnings <suppress-warnings:true|false>", "When true, warning messages are filtered from build output to conserve context (example: true)", (value) => value !== 'false')
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectPath !== undefined) args.projectPath = cmdOpts.projectPath;
		if (cmdOpts.workspacePath !== undefined) args.workspacePath = cmdOpts.workspacePath;
		if (cmdOpts.scheme !== undefined) args.scheme = cmdOpts.scheme;
		if (cmdOpts.configuration !== undefined) args.configuration = cmdOpts.configuration;
		if (cmdOpts.simulatorName !== undefined) args.simulatorName = cmdOpts.simulatorName;
		if (cmdOpts.simulatorId !== undefined) args.simulatorId = cmdOpts.simulatorId;
		if (cmdOpts.deviceId !== undefined) args.deviceId = cmdOpts.deviceId;
		if (cmdOpts.useLatestOS !== undefined) args.useLatestOS = cmdOpts.useLatestOS;
		if (cmdOpts.arch !== undefined) args.arch = cmdOpts.arch;
		if (cmdOpts.suppressWarnings !== undefined) args.suppressWarnings = cmdOpts.suppressWarnings;
			const call = (proxy.sessionSetDefaults as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.session-set-defaults(projectPath: \"/path/to/fi, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (5): simulatorId, deviceId, useLatestOS, arch, suppressWarnings" + '\n');

program
	.command("session-show-defaults")
	.summary("session-show-defaults [--raw <json>]")
	.description("Show current session defaults.")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.sessionShowDefaults as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.session-show-defaults()");

program
	.command("boot-sim")
	.summary("boot-sim [--raw <json>]")
	.description("Boots an iOS simulator.")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("boot_sim")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.bootSim as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.boot_sim()");

program
	.command("build-run-sim")
	.summary("build-run-sim [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.description("Builds and runs an app on an iOS simulator.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Path where build products and other derived data will go (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional xcodebuild arguments (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--prefer-xcodebuild <prefer-xcodebuild:true|false>", "If true, prefers xcodebuild over the experimental incremental build system, useful for when incremental build system fails. (example: true)", (value) => value !== 'false')
	
	.alias("build_run_sim")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
		if (cmdOpts.preferXcodebuild !== undefined) args.preferXcodebuild = cmdOpts.preferXcodebuild;
			const call = (proxy.buildRunSim as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.build_run_sim(derivedDataPath: \"/path/to/file., ...)");

program
	.command("build-sim")
	.summary("build-sim [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.description("Builds an app for an iOS simulator.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Path where build products and other derived data will go (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional xcodebuild arguments (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--prefer-xcodebuild <prefer-xcodebuild:true|false>", "If true, prefers xcodebuild over the experimental incremental build system, useful for when incremental build system fails. (example: true)", (value) => value !== 'false')
	
	.alias("build_sim")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
		if (cmdOpts.preferXcodebuild !== undefined) args.preferXcodebuild = cmdOpts.preferXcodebuild;
			const call = (proxy.buildSim as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.build_sim(derivedDataPath: \"/path/to/file.md\", ...)");

program
	.command("describe-ui")
	.summary("describe-ui [--raw <json>]")
	.description("Gets entire view hierarchy with precise frame coordinates (x, y, width, height) for all visible elements. Use this before UI interactions or after layout changes - do NOT guess coordinates from screenshots. Returns JSON tree with frame data for accurate automation.")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("describe_ui")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.describeUi as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.describe_ui()");

program
	.command("get-sim-app-path")
	.summary("get-sim-app-path --platform <platform:iOS Simulator|watchOS Simulator|tvOS Simulator|visionOS Simulator> [--raw <json>]")
	.description("Retrieves the built app path for an iOS simulator.")
	.usage("--platform <platform:iOS Simulator|watchOS Simulator|tvOS Simulator|visionOS Simulator> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--platform <platform:iOS Simulator|watchOS Simulator|tvOS Simulator|visionOS Simulator>", "Target simulator platform (Required) (choices: iOS Simulator, watchOS Simulator, tvOS Simulator, visionOS Simulator; example: iOS Simulator)")
	
	.alias("get_sim_app_path")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.platform !== undefined) args.platform = cmdOpts.platform;
			const call = (proxy.getSimAppPath as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.get_sim_app_path(platform: \"iOS Simulator\")");

program
	.command("install-app-sim")
	.summary("install-app-sim --app-path <app-path> [--raw <json>]")
	.description("Installs an app in an iOS simulator.")
	.usage("--app-path <app-path> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--app-path <app-path>", "Path to the .app bundle to install (full path to the .app directory) (example: /path/to/file.md)")
	
	.alias("install_app_sim")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.appPath !== undefined) args.appPath = cmdOpts.appPath;
			const call = (proxy.installAppSim as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.install_app_sim(appPath: \"/path/to/file.md\")");

program
	.command("launch-app-logs-sim")
	.summary("launch-app-logs-sim --bundle-id <bundle-id> [--args <args:value1,value2>] [--raw <json>]")
	.description("Launches an app in an iOS simulator and captures its logs.")
	.usage("--bundle-id <bundle-id> [--args <args:value1,value2>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--bundle-id <bundle-id>", "Bundle identifier of the app to launch (e.g., 'com.example.MyApp') (example: example-id)")
	.option("--args <args:value1,value2>", "Additional arguments to pass to the app (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	
	.alias("launch_app_logs_sim")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.bundleId !== undefined) args.bundleId = cmdOpts.bundleId;
		if (cmdOpts.args !== undefined) args.args = cmdOpts.args;
			const call = (proxy.launchAppLogsSim as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.launch_app_logs_sim(bundleId: \"example-id\", ar, ...)");

program
	.command("launch-app-sim")
	.summary("launch-app-sim --bundle-id <bundle-id> [--args <args:value1,value2>] [--raw <json>]")
	.description("Launches an app in an iOS simulator.")
	.usage("--bundle-id <bundle-id> [--args <args:value1,value2>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--bundle-id <bundle-id>", "Bundle identifier of the app to launch (e.g., 'com.example.MyApp') (example: example-id)")
	.option("--args <args:value1,value2>", "Additional arguments to pass to the app (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	
	.alias("launch_app_sim")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.bundleId !== undefined) args.bundleId = cmdOpts.bundleId;
		if (cmdOpts.args !== undefined) args.args = cmdOpts.args;
			const call = (proxy.launchAppSim as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.launch_app_sim(bundleId: \"example-id\", args: [, ...)");

program
	.command("list-sims")
	.summary("list-sims [--enabled <enabled:true|false>] [--raw <json>]")
	.description("Lists available iOS simulators with their UUIDs. ")
	.usage("[--enabled <enabled:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--enabled <enabled:true|false>", "Optional flag to enable the listing operation. (example: true)", (value) => value !== 'false')
	
	.alias("list_sims")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.enabled !== undefined) args.enabled = cmdOpts.enabled;
			const call = (proxy.listSims as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.list_sims(enabled: true)");

program
	.command("open-sim")
	.summary("open-sim [--raw <json>]")
	.description("Opens the iOS Simulator app.")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("open_sim")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.openSim as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.open_sim()");

program
	.command("record-sim-video")
	.summary("record-sim-video [--start <start:true|false>] [--stop <stop:true|false>] [--fps <fps:number>] [--output-file <output-file>] [--raw <json>]")
	.description("Starts or stops video capture for an iOS simulator.")
	.usage("[--start <start:true|false>] [--stop <stop:true|false>] [--fps <fps:number>] [--output-file <output-file>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--start <start:true|false>", "Start recording if true (example: true)", (value) => value !== 'false')
	.option("--stop <stop:true|false>", "Stop recording if true (example: true)", (value) => value !== 'false')
	.option("--fps <fps:number>", "Frames per second (default 30) (example: 1)", (value) => parseFloat(value))
	.option("--output-file <output-file>", "Destination MP4 path to move the recorded video to on stop")
	
	.alias("record_sim_video")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.start !== undefined) args.start = cmdOpts.start;
		if (cmdOpts.stop !== undefined) args.stop = cmdOpts.stop;
		if (cmdOpts.fps !== undefined) args.fps = cmdOpts.fps;
		if (cmdOpts.outputFile !== undefined) args.outputFile = cmdOpts.outputFile;
			const call = (proxy.recordSimVideo as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.record_sim_video(start: true, stop: true, fps: 1)");

program
	.command("screenshot")
	.summary("screenshot [--raw <json>]")
	.description("Captures screenshot for visual verification. For UI coordinates, use describe_ui instead (don't determine coordinates from screenshots).")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.screenshot as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.screenshot()");

program
	.command("stop-app-sim")
	.summary("stop-app-sim --bundle-id <bundle-id> [--raw <json>]")
	.description("Stops an app running in an iOS simulator.")
	.usage("--bundle-id <bundle-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--bundle-id <bundle-id>", "Bundle identifier of the app to stop (e.g., 'com.example.MyApp') (example: example-id)")
	
	.alias("stop_app_sim")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.bundleId !== undefined) args.bundleId = cmdOpts.bundleId;
			const call = (proxy.stopAppSim as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.stop_app_sim(bundleId: \"example-id\")");

program
	.command("test-sim")
	.summary("test-sim [--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--test-runner-env <test-runner-env>] [--raw <json>]")
	.description("Runs tests on an iOS simulator.")
	.usage("[--derived-data-path <derived-data-path>] [--extra-args <extra-args:value1,value2>] [--prefer-xcodebuild <prefer-xcodebuild:true|false>] [--test-runner-env <test-runner-env>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--derived-data-path <derived-data-path>", "Path where build products and other derived data will go (example: /path/to/file.md)")
	.option("--extra-args <extra-args:value1,value2>", "Additional xcodebuild arguments (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--prefer-xcodebuild <prefer-xcodebuild:true|false>", "If true, prefers xcodebuild over the experimental incremental build system, useful for when incremental build system fails. (example: true)", (value) => value !== 'false')
	.option("--test-runner-env <test-runner-env>", "Environment variables to pass to the test runner (TEST_RUNNER_ prefix added automatically)")
	
	.alias("test_sim")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.derivedDataPath !== undefined) args.derivedDataPath = cmdOpts.derivedDataPath;
		if (cmdOpts.extraArgs !== undefined) args.extraArgs = cmdOpts.extraArgs;
		if (cmdOpts.preferXcodebuild !== undefined) args.preferXcodebuild = cmdOpts.preferXcodebuild;
		if (cmdOpts.testRunnerEnv !== undefined) args.testRunnerEnv = cmdOpts.testRunnerEnv;
			const call = (proxy.testSim as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.test_sim(derivedDataPath: \"/path/to/file.md\", ...)");

program
	.command("erase-sims")
	.summary("erase-sims [--shutdown-first <shutdown-first:true|false>] [--raw <json>]")
	.description("Erases a simulator by UDID.")
	.usage("[--shutdown-first <shutdown-first:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--shutdown-first <shutdown-first:true|false>", "If true, shuts down the simulator before erasing. (example: true)", (value) => value !== 'false')
	
	.alias("erase_sims")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.shutdownFirst !== undefined) args.shutdownFirst = cmdOpts.shutdownFirst;
			const call = (proxy.eraseSims as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.erase_sims(shutdownFirst: true)");

program
	.command("reset-sim-location")
	.summary("reset-sim-location [--raw <json>]")
	.description("Resets the simulator's location to default.")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("reset_sim_location")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.resetSimLocation as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.reset_sim_location()");

program
	.command("set-sim-appearance")
	.summary("set-sim-appearance --mode <mode:dark|light> [--raw <json>]")
	.description("Sets the appearance mode (dark/light) of an iOS simulator.")
	.usage("--mode <mode:dark|light> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--mode <mode:dark|light>", "The appearance mode to set (either \"dark\" or \"light\") (choices: dark, light; example: dark)")
	
	.alias("set_sim_appearance")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.mode !== undefined) args.mode = cmdOpts.mode;
			const call = (proxy.setSimAppearance as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.set_sim_appearance(mode: \"dark\")");

program
	.command("set-sim-location")
	.summary("set-sim-location --latitude <latitude:number> --longitude <longitude:number> [--raw <json>]")
	.description("Sets a custom GPS location for the simulator.")
	.usage("--latitude <latitude:number> --longitude <longitude:number> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--latitude <latitude:number>", "The latitude for the custom location. (example: 1)", (value) => parseFloat(value))
	.requiredOption("--longitude <longitude:number>", "The longitude for the custom location. (example: 1)", (value) => parseFloat(value))
	
	.alias("set_sim_location")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.latitude !== undefined) args.latitude = cmdOpts.latitude;
		if (cmdOpts.longitude !== undefined) args.longitude = cmdOpts.longitude;
			const call = (proxy.setSimLocation as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.set_sim_location(latitude: 1, longitude: 1)");

program
	.command("sim-statusbar")
	.summary("sim-statusbar --data-network <data-network:clear|hide|wifi|3g|4g|lte|lte-a|lte+|5g|5g+|5g-uwb|5g-uc> [--raw <json>]")
	.description("Sets the data network indicator in the iOS simulator status bar. Use \"clear\" to reset all overrides, or specify a network type (hide, wifi, 3g, 4g, lte, lte-a, lte+, 5g, 5g+, 5g-uwb, 5g-uc).")
	.usage("--data-network <data-network:clear|hide|wifi|3g|4g|lte|lte-a|lte+|5g|5g+|5g-uwb|5g-uc> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--data-network <data-network:clear|hide|wifi|3g|4g|lte|lte-a|lte+|5g|5g+|5g-uwb|5g-uc>", "Data network type to display in status bar. Use \"clear\" to reset all overrides. Valid values: clear, hide, wifi, 3g, 4g, lte, lte-a, lte+, 5g, 5g+, 5g-uwb, 5g-uc. (choices: clear, hide, wifi, 3g, 4g, lte, lte-a, lte+, 5g, 5g+, 5g-uwb, 5g-uc; example: clear)")
	
	.alias("sim_statusbar")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.dataNetwork !== undefined) args.dataNetwork = cmdOpts.dataNetwork;
			const call = (proxy.simStatusbar as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.sim_statusbar(dataNetwork: \"clear\")");

program
	.command("swift-package-build")
	.summary("swift-package-build --package-path <package-path> [--target-name <target-name>] [--configuration <configuration:debug|release>] [--architectures <architectures:value1,value2>] [--parse-as-library <parse-as-library:true|false>] [--raw <json>]")
	.description("Builds a Swift Package with swift build")
	.usage("--package-path <package-path> [--target-name <target-name>] [--configuration <configuration:debug|release>] [--architectures <architectures:value1,value2>] [--parse-as-library <parse-as-library:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--package-path <package-path>", "Path to the Swift package root (Required) (example: /path/to/file.md)")
	.option("--target-name <target-name>", "Optional target to build")
	.option("--configuration <configuration:debug|release>", "Swift package configuration (debug, release) (choices: debug, release; example: debug)")
	.option("--architectures <architectures:value1,value2>", "Target architectures to build for (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--parse-as-library <parse-as-library:true|false>", "Build as library instead of executable (example: true)", (value) => value !== 'false')
	
	.alias("swift_package_build")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.packagePath !== undefined) args.packagePath = cmdOpts.packagePath;
		if (cmdOpts.targetName !== undefined) args.targetName = cmdOpts.targetName;
		if (cmdOpts.configuration !== undefined) args.configuration = cmdOpts.configuration;
		if (cmdOpts.architectures !== undefined) args.architectures = cmdOpts.architectures;
		if (cmdOpts.parseAsLibrary !== undefined) args.parseAsLibrary = cmdOpts.parseAsLibrary;
			const call = (proxy.swiftPackageBuild as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.swift_package_build(packagePath: \"/path/to/fil, ...)");

program
	.command("swift-package-clean")
	.summary("swift-package-clean --package-path <package-path> [--raw <json>]")
	.description("Cleans Swift Package build artifacts and derived data")
	.usage("--package-path <package-path> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--package-path <package-path>", "Path to the Swift package root (Required) (example: /path/to/file.md)")
	
	.alias("swift_package_clean")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.packagePath !== undefined) args.packagePath = cmdOpts.packagePath;
			const call = (proxy.swiftPackageClean as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.swift_package_clean(packagePath: \"/path/to/file.md\")");

program
	.command("swift-package-list")
	.summary("swift-package-list [--raw <json>]")
	.description("Lists currently running Swift Package processes")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("swift_package_list")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.swiftPackageList as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.swift_package_list()");

program
	.command("swift-package-run")
	.summary("swift-package-run --package-path <package-path> [--executable-name <executable-name>] [--arguments <arguments:value1,value2>] [--configuration <configuration:debug|release>] [--timeout <timeout:number>] [--raw <json>]")
	.description("Runs an executable target from a Swift Package with swift run")
	.usage("--package-path <package-path> [--executable-name <executable-name>] [--arguments <arguments:value1,value2>] [--configuration <configuration:debug|release>] [--timeout <timeout:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--package-path <package-path>", "Path to the Swift package root (Required) (example: /path/to/file.md)")
	.option("--executable-name <executable-name>", "Name of executable to run (defaults to package name)")
	.option("--arguments <arguments:value1,value2>", "Arguments to pass to the executable (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--configuration <configuration:debug|release>", "Build configuration: 'debug' (default) or 'release' (choices: debug, release; example: debug)")
	.option("--timeout <timeout:number>", "Timeout in seconds (default: 30, max: 300) (example: 1)", (value) => parseFloat(value))
	.option("--background <background:true|false>", "Run in background and return immediately (default: false) (example: true)", (value) => value !== 'false')
	.option("--parse-as-library <parse-as-library:true|false>", "Add -parse-as-library flag for @main support (default: false) (example: true)", (value) => value !== 'false')
	
	.alias("swift_package_run")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.packagePath !== undefined) args.packagePath = cmdOpts.packagePath;
		if (cmdOpts.executableName !== undefined) args.executableName = cmdOpts.executableName;
		if (cmdOpts.arguments !== undefined) args.arguments = cmdOpts.arguments;
		if (cmdOpts.configuration !== undefined) args.configuration = cmdOpts.configuration;
		if (cmdOpts.timeout !== undefined) args.timeout = cmdOpts.timeout;
		if (cmdOpts.background !== undefined) args.background = cmdOpts.background;
		if (cmdOpts.parseAsLibrary !== undefined) args.parseAsLibrary = cmdOpts.parseAsLibrary;
			const call = (proxy.swiftPackageRun as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.swift_package_run(packagePath: \"/path/to/file., ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (2): background, parseAsLibrary" + '\n');

program
	.command("swift-package-stop")
	.summary("swift-package-stop --pid <pid:number> [--raw <json>]")
	.description("Stops a running Swift Package executable started with swift_package_run")
	.usage("--pid <pid:number> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--pid <pid:number>", "Process ID (PID) of the running executable (example: 1)", (value) => parseFloat(value))
	
	.alias("swift_package_stop")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.pid !== undefined) args.pid = cmdOpts.pid;
			const call = (proxy.swiftPackageStop as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.swift_package_stop(pid: 1)");

program
	.command("swift-package-test")
	.summary("swift-package-test --package-path <package-path> [--test-product <test-product>] [--filter <filter>] [--configuration <configuration:debug|release>] [--parallel <parallel:true|false>] [--raw <json>]")
	.description("Runs tests for a Swift Package with swift test")
	.usage("--package-path <package-path> [--test-product <test-product>] [--filter <filter>] [--configuration <configuration:debug|release>] [--parallel <parallel:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--package-path <package-path>", "Path to the Swift package root (Required) (example: /path/to/file.md)")
	.option("--test-product <test-product>", "Optional specific test product to run")
	.option("--filter <filter>", "Filter tests by name (regex pattern)")
	.option("--configuration <configuration:debug|release>", "Swift package configuration (debug, release) (choices: debug, release; example: debug)")
	.option("--parallel <parallel:true|false>", "Run tests in parallel (default: true) (example: true)", (value) => value !== 'false')
	.option("--show-codecov <show-codecov:true|false>", "Show code coverage (default: false) (example: true)", (value) => value !== 'false')
	.option("--parse-as-library <parse-as-library:true|false>", "Add -parse-as-library flag for @main support (default: false) (example: true)", (value) => value !== 'false')
	
	.alias("swift_package_test")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.packagePath !== undefined) args.packagePath = cmdOpts.packagePath;
		if (cmdOpts.testProduct !== undefined) args.testProduct = cmdOpts.testProduct;
		if (cmdOpts.filter !== undefined) args.filter = cmdOpts.filter;
		if (cmdOpts.configuration !== undefined) args.configuration = cmdOpts.configuration;
		if (cmdOpts.parallel !== undefined) args.parallel = cmdOpts.parallel;
		if (cmdOpts.showCodecov !== undefined) args.showCodecov = cmdOpts.showCodecov;
		if (cmdOpts.parseAsLibrary !== undefined) args.parseAsLibrary = cmdOpts.parseAsLibrary;
			const call = (proxy.swiftPackageTest as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.swift_package_test(packagePath: \"/path/to/file, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (2): showCodecov, parseAsLibrary" + '\n');

program
	.command("button")
	.summary("button --button-type <button-type:apple-pay|home|lock|side-button|siri> [--duration <duration:number>] [--raw <json>]")
	.description("Press hardware button on iOS simulator. Supported buttons: apple-pay, home, lock, side-button, siri")
	.usage("--button-type <button-type:apple-pay|home|lock|side-button|siri> [--duration <duration:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--button-type <button-type:apple-pay|home|lock|side-button|siri>", "Set buttonType. (choices: apple-pay, home, lock, side-button, siri; example: apple-pay)")
	.option("--duration <duration:number>", "Set duration. (example: 1)", (value) => parseFloat(value))
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.buttonType !== undefined) args.buttonType = cmdOpts.buttonType;
		if (cmdOpts.duration !== undefined) args.duration = cmdOpts.duration;
			const call = (proxy.button as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.button(buttonType: \"apple-pay\", duration: 1)");

program
	.command("gesture")
	.summary("gesture --preset <preset:scroll-up|scroll-down|scroll-left|scroll-right|swipe-from-left-edge|swipe-from-right-edge|swipe-from-top-edge|swipe-from-bottom-edge> [--screen-width <screen-width:number>] [--screen-height <screen-height:number>] [--duration <duration:number>] [--delta <delta:number>] [--raw <json>]")
	.description("Perform gesture on iOS simulator using preset gestures: scroll-up, scroll-down, scroll-left, scroll-right, swipe-from-left-edge, swipe-from-right-edge, swipe-from-top-edge, swipe-from-bottom-edge")
	.usage("--preset <preset:scroll-up|scroll-down|scroll-left|scroll-right|swipe-from-left-edge|swipe-from-right-edge|swipe-from-top-edge|swipe-from-bottom-edge> [--screen-width <screen-width:number>] [--screen-height <screen-height:number>] [--duration <duration:number>] [--delta <delta:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--preset <preset:scroll-up|scroll-down|scroll-left|scroll-right|swipe-from-left-edge|swipe-from-right-edge|swipe-from-top-edge|swipe-from-bottom-edge>", "The gesture preset to perform. Must be one of: scroll-up, scroll-down, scroll-left, scroll-right, swipe-from-left-edge, swipe-from-right-edge, swipe-from-top-edge, swipe-from-bottom-edge. (choices: scroll-up, scroll-down, scroll-left, scroll-right, swipe-from-left-edge, swipe-from-right-edge, swipe-from-top-edge, swipe-from-bottom-edge; example: scroll-up)")
	.option("--screen-width <screen-width:number>", "Optional: Screen width in pixels. Used for gesture calculations. Auto-detected if not provided. (example: 1)", (value) => parseFloat(value))
	.option("--screen-height <screen-height:number>", "Optional: Screen height in pixels. Used for gesture calculations. Auto-detected if not provided. (example: 1)", (value) => parseFloat(value))
	.option("--duration <duration:number>", "Optional: Duration of the gesture in seconds. (example: 1)", (value) => parseFloat(value))
	.option("--delta <delta:number>", "Optional: Distance to move in pixels. (example: 1)", (value) => parseFloat(value))
	.option("--pre-delay <pre-delay:number>", "Optional: Delay before starting the gesture in seconds. (example: 1)", (value) => parseFloat(value))
	.option("--post-delay <post-delay:number>", "Optional: Delay after completing the gesture in seconds. (example: 1)", (value) => parseFloat(value))
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.preset !== undefined) args.preset = cmdOpts.preset;
		if (cmdOpts.screenWidth !== undefined) args.screenWidth = cmdOpts.screenWidth;
		if (cmdOpts.screenHeight !== undefined) args.screenHeight = cmdOpts.screenHeight;
		if (cmdOpts.duration !== undefined) args.duration = cmdOpts.duration;
		if (cmdOpts.delta !== undefined) args.delta = cmdOpts.delta;
		if (cmdOpts.preDelay !== undefined) args.preDelay = cmdOpts.preDelay;
		if (cmdOpts.postDelay !== undefined) args.postDelay = cmdOpts.postDelay;
			const call = (proxy.gesture as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.gesture(preset: \"scroll-up\", screenWidth: 1, s, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (2): preDelay, postDelay" + '\n');

program
	.command("key-press")
	.summary("key-press --key-code <key-code:number> [--duration <duration:number>] [--raw <json>]")
	.description("Press a single key by keycode on the simulator. Common keycodes: 40=Return, 42=Backspace, 43=Tab, 44=Space, 58-67=F1-F10.")
	.usage("--key-code <key-code:number> [--duration <duration:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--key-code <key-code:number>", "Set keyCode. (example: 1)", (value) => parseFloat(value))
	.option("--duration <duration:number>", "Set duration. (example: 1)", (value) => parseFloat(value))
	
	.alias("key_press")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.keyCode !== undefined) args.keyCode = cmdOpts.keyCode;
		if (cmdOpts.duration !== undefined) args.duration = cmdOpts.duration;
			const call = (proxy.keyPress as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.key_press(keyCode: 1, duration: 1)");

program
	.command("key-sequence")
	.summary("key-sequence --key-codes <key-codes:value1,value2> [--delay <delay:number>] [--raw <json>]")
	.description("Press key sequence using HID keycodes on iOS simulator with configurable delay")
	.usage("--key-codes <key-codes:value1,value2> [--delay <delay:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--key-codes <key-codes:value1,value2>", "Set keyCodes. (example: value1,value2)", (value) => value.split(',').map((v) => parseFloat(v.trim())))
	.option("--delay <delay:number>", "Set delay. (example: 1)", (value) => parseFloat(value))
	
	.alias("key_sequence")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.keyCodes !== undefined) args.keyCodes = cmdOpts.keyCodes;
		if (cmdOpts.delay !== undefined) args.delay = cmdOpts.delay;
			const call = (proxy.keySequence as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.key_sequence(keyCodes: [\"value1\", \"value2\"], d, ...)");

program
	.command("long-press")
	.summary("long-press --x <x:number> --y <y:number> --duration <duration:number> [--raw <json>]")
	.description("Long press at specific coordinates for given duration (ms). Use describe_ui for precise coordinates (don't guess from screenshots).")
	.usage("--x <x:number> --y <y:number> --duration <duration:number> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--x <x:number>", "Set x. (example: 1)", (value) => parseFloat(value))
	.requiredOption("--y <y:number>", "Set y. (example: 1)", (value) => parseFloat(value))
	.requiredOption("--duration <duration:number>", "Set duration. (example: 1)", (value) => parseFloat(value))
	
	.alias("long_press")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.x !== undefined) args.x = cmdOpts.x;
		if (cmdOpts.y !== undefined) args.y = cmdOpts.y;
		if (cmdOpts.duration !== undefined) args.duration = cmdOpts.duration;
			const call = (proxy.longPress as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.long_press(x: 1, y: 1, duration: 1)");

program
	.command("swipe")
	.summary("swipe --x1 <x1:number> --y1 <y1:number> --x2 <x2:number> --y2 <y2:number> [--duration <duration:number>] [--raw <json>]")
	.description("Swipe from one point to another. Use describe_ui for precise coordinates (don't guess from screenshots). Supports configurable timing.")
	.usage("--x1 <x1:number> --y1 <y1:number> --x2 <x2:number> --y2 <y2:number> [--duration <duration:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--x1 <x1:number>", "Set x1. (example: 1)", (value) => parseFloat(value))
	.requiredOption("--y1 <y1:number>", "Set y1. (example: 1)", (value) => parseFloat(value))
	.requiredOption("--x2 <x2:number>", "Set x2. (example: 1)", (value) => parseFloat(value))
	.requiredOption("--y2 <y2:number>", "Set y2. (example: 1)", (value) => parseFloat(value))
	.option("--duration <duration:number>", "Set duration. (example: 1)", (value) => parseFloat(value))
	.option("--delta <delta:number>", "Set delta. (example: 1)", (value) => parseFloat(value))
	.option("--pre-delay <pre-delay:number>", "Set preDelay. (example: 1)", (value) => parseFloat(value))
	.option("--post-delay <post-delay:number>", "Set postDelay. (example: 1)", (value) => parseFloat(value))
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.x1 !== undefined) args.x1 = cmdOpts.x1;
		if (cmdOpts.y1 !== undefined) args.y1 = cmdOpts.y1;
		if (cmdOpts.x2 !== undefined) args.x2 = cmdOpts.x2;
		if (cmdOpts.y2 !== undefined) args.y2 = cmdOpts.y2;
		if (cmdOpts.duration !== undefined) args.duration = cmdOpts.duration;
		if (cmdOpts.delta !== undefined) args.delta = cmdOpts.delta;
		if (cmdOpts.preDelay !== undefined) args.preDelay = cmdOpts.preDelay;
		if (cmdOpts.postDelay !== undefined) args.postDelay = cmdOpts.postDelay;
			const call = (proxy.swipe as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.swipe(x1: 1, y1: 1, x2: 1, y2: 1, duration: 1)")
	.addHelpText('afterAll', () => '\n' + "// optional (3): delta, preDelay, postDelay" + '\n');

program
	.command("tap")
	.summary("tap [--x <x:number>] [--y <y:number>] [--id <id>] [--label <label>] [--pre-delay <pre-delay:number>] [--raw <json>]")
	.description("Tap at specific coordinates or target elements by accessibility id or label. Use describe_ui to get precise element coordinates prior to using x/y parameters (don't guess from screenshots). Supports optional timing delays.")
	.usage("[--x <x:number>] [--y <y:number>] [--id <id>] [--label <label>] [--pre-delay <pre-delay:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--x <x:number>", "Set x. (example: 1)", (value) => parseFloat(value))
	.option("--y <y:number>", "Set y. (example: 1)", (value) => parseFloat(value))
	.option("--id <id>", "Set id. (example: example-id)")
	.option("--label <label>", "Set label.")
	.option("--pre-delay <pre-delay:number>", "Set preDelay. (example: 1)", (value) => parseFloat(value))
	.option("--post-delay <post-delay:number>", "Set postDelay. (example: 1)", (value) => parseFloat(value))
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.x !== undefined) args.x = cmdOpts.x;
		if (cmdOpts.y !== undefined) args.y = cmdOpts.y;
		if (cmdOpts.id !== undefined) args.id = cmdOpts.id;
		if (cmdOpts.label !== undefined) args.label = cmdOpts.label;
		if (cmdOpts.preDelay !== undefined) args.preDelay = cmdOpts.preDelay;
		if (cmdOpts.postDelay !== undefined) args.postDelay = cmdOpts.postDelay;
			const call = (proxy.tap as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.tap(x: 1, y: 1, id: \"example-id\", preDelay: 1)")
	.addHelpText('afterAll', () => '\n' + "// optional (1): postDelay" + '\n');

program
	.command("touch")
	.summary("touch --x <x:number> --y <y:number> [--down <down:true|false>] [--up <up:true|false>] [--delay <delay:number>] [--raw <json>]")
	.description("Perform touch down/up events at specific coordinates. Use describe_ui for precise coordinates (don't guess from screenshots).")
	.usage("--x <x:number> --y <y:number> [--down <down:true|false>] [--up <up:true|false>] [--delay <delay:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--x <x:number>", "Set x. (example: 1)", (value) => parseFloat(value))
	.requiredOption("--y <y:number>", "Set y. (example: 1)", (value) => parseFloat(value))
	.option("--down <down:true|false>", "Set down. (example: true)", (value) => value !== 'false')
	.option("--up <up:true|false>", "Set up. (example: true)", (value) => value !== 'false')
	.option("--delay <delay:number>", "Set delay. (example: 1)", (value) => parseFloat(value))
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.x !== undefined) args.x = cmdOpts.x;
		if (cmdOpts.y !== undefined) args.y = cmdOpts.y;
		if (cmdOpts.down !== undefined) args.down = cmdOpts.down;
		if (cmdOpts.up !== undefined) args.up = cmdOpts.up;
		if (cmdOpts.delay !== undefined) args.delay = cmdOpts.delay;
			const call = (proxy.touch as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.touch(x: 1, y: 1, down: true, up: true, delay: 1)");

program
	.command("type-text")
	.summary("type-text --text <text> [--raw <json>]")
	.description("Type text (supports US keyboard characters). Use describe_ui to find text field, tap to focus, then type.")
	.usage("--text <text> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--text <text>", "Set text.")
	
	.alias("type_text")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.text !== undefined) args.text = cmdOpts.text;
			const call = (proxy.typeText as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call xcodebuildmcp.type_text(text: \"value\")");

program
	.command('__mcporter_inspect', { hidden: true })
	.description('Internal metadata printer for mcporter inspect-cli.')
	.action(() => {
		const payload = buildMetadataPayload();
		console.log(JSON.stringify(payload, null, 2));
	});

configureToolCommandHelps();

const FORCE_COLOR = process.env.FORCE_COLOR?.toLowerCase();
const forceDisableColor = FORCE_COLOR === '0' || FORCE_COLOR === 'false';
const forceEnableColor = FORCE_COLOR === '1' || FORCE_COLOR === 'true' || FORCE_COLOR === '2' || FORCE_COLOR === '3';
const hasNoColor = process.env.NO_COLOR !== undefined;
const stdoutStream = process.stdout as NodeJS.WriteStream | undefined;
const supportsAnsiColor = !hasNoColor && (forceEnableColor || (!forceDisableColor && Boolean(stdoutStream?.isTTY)));

const tint = {
	bold(text: string): string {
		return supportsAnsiColor ? '[1m' + text + '[0m' : text;
	},
	dim(text: string): string {
		return supportsAnsiColor ? '[90m' + text + '[0m' : text;
	},
	extraDim(text: string): string {
		return supportsAnsiColor ? '[38;5;244m' + text + '[0m' : text;
	},
};

function configureGeneratedCommandHelp(command: Command): void {
	command.configureHelp({
		commandUsage(target) {
			const usage = (target.name() + ' ' + target.usage()).trim() || target.name();
			return supportsAnsiColor ? tint.bold(usage) : usage;
		},
		optionTerm(option) {
			const term = option.flags ?? '';
			return supportsAnsiColor ? tint.bold(term) : term;
		},
		optionDescription(option) {
			const description = option.description ?? '';
			return supportsAnsiColor ? tint.extraDim(description) : description;
		},
	});
}

function configureToolCommandHelps(): void {
	program.commands.forEach((cmd) => {
		if (cmd.name() === '__mcporter_inspect') {
			return;
		}
		configureGeneratedCommandHelp(cmd);
	});
}

function renderStandaloneHelp(): string {
	const colorfulTitle = tint.bold(embeddedName) + ' ' + tint.dim('â€” ' + embeddedDescription);
	const plainTitle = embeddedName + ' â€” ' + embeddedDescription;
	const title = supportsAnsiColor ? colorfulTitle : plainTitle;
	const lines = [title, '', 'Usage: ' + embeddedName + ' <command> [options]', ''];
	if (generatorTools) {
		lines.push(formatEmbeddedTools());
	}
	lines.push('', formatGlobalFlags(), '', formatQuickStart());
	if (generatorInfo) {
		lines.push('', tint.extraDim(generatorInfo));
	}
	return lines.join('\n');
}

program.helpInformation = () => renderStandaloneHelp();

function formatEmbeddedTools(): string {
	const header = supportsAnsiColor ? tint.bold('Embedded tools') : 'Embedded tools';
	if (!generatorTools.length) {
		return header;
	}
	const lines = [header];
	generatorTools.forEach((entry) => {
		const renderedDesc = entry.description
			? supportsAnsiColor
				? tint.extraDim(entry.description)
				: entry.description
			: undefined;
		const base = renderedDesc ? entry.name + ' - ' + renderedDesc : entry.name;
		lines.push('  ' + base);
		if (entry.flags) {
			const renderedFlags = supportsAnsiColor ? tint.extraDim(entry.flags) : entry.flags;
			lines.push('    ' + renderedFlags);
		}
		lines.push('');
	});
	if (lines[lines.length - 1] === '') {
		lines.pop();
	}
	return lines.join('\n');
}

function formatGlobalFlags(): string {
	const header = supportsAnsiColor ? tint.bold('Global flags') : 'Global flags';
	const entries = [
		['-t, --timeout <ms>', 'Call timeout in milliseconds'],
		['-o, --output <format>', 'text | markdown | json | raw (default text)'],
	];
	const formatted = entries.map(([flag, summary]) => '  ' + flag.padEnd(28) + summary);
	return [header, ...formatted].join('\n');
}

function formatQuickStart(): string {
  const header = supportsAnsiColor ? tint.bold('Quick start') : 'Quick start';
  const examples = quickStartExamples();
  if (!examples.length) {
    return header;
  }
  const formatted = examples.map(([cmd, note]) => '  ' + cmd + '\n    ' + tint.dim('# ' + note));
  return [header, ...formatted].join('\n');
}

function quickStartExamples(): Array<[string, string]> {
  const examples: Array<[string, string]> = [];
  const commandMap = new Map<string, string>();
  program.commands.forEach((cmd) => {
    const name = cmd.name();
    if (name !== '__mcporter_inspect') {
      commandMap.set(name, name);
    }
  });
  const embedded = Array.isArray(generatorTools) ? generatorTools : [];
  for (const entry of embedded.slice(0, 3)) {
    const commandName = commandMap.get(entry.name) ?? entry.name;
    const flags = entry.flags ? ' ' + entry.flags.replace(/<[^>]+>/g, '<value>') : '';
    examples.push([embeddedName + ' ' + commandName + flags, 'invoke ' + commandName]);
  }
  if (!examples.length) {
    examples.push([embeddedName + ' <tool> --key value', 'invoke a tool with flags']);
  }
  return examples;
}

function printResult(result: unknown, format: string) {
	const wrapped = createCallResult(result);
	switch (format) {
		case 'json': {
			const json = wrapped.json();
			if (json) {
				console.log(JSON.stringify(json, null, 2));
				return;
			}
			break;
		}
		case 'markdown': {
			const markdown = wrapped.markdown();
			if (markdown) {
				console.log(markdown);
				return;
			}
			break;
		}
		case 'raw': {
			console.log(JSON.stringify(wrapped.raw, null, 2));
			return;
		}
	}
	const text = wrapped.text();
	if (text) {
		console.log(text);
	} else {
		console.log(JSON.stringify(wrapped.raw, null, 2));
	}
}

function normalizeEmbeddedServer(server: typeof embeddedServer) {
	const base = { ...server } as Record<string, unknown>;
	if ((server.command as any).kind === 'http') {
		const urlRaw = (server.command as any).url;
		const urlValue = typeof urlRaw === 'string' ? urlRaw : String(urlRaw);
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				url: new URL(urlValue),
			},
		};
	}
	if ((server.command as any).kind === 'stdio') {
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				args: [ ...((server.command as any).args ?? []) ],
			},
		};
	}
	return base;
}

function determineArtifactKind(): 'template' | 'bundle' | 'binary' {
	const scriptPath = typeof process !== 'undefined' && Array.isArray(process.argv) ? process.argv[1] ?? '' : '';
	if (scriptPath.endsWith('.ts')) {
		return 'template';
	}
	if (scriptPath.endsWith('.js')) {
		return 'bundle';
	}
	return 'binary';
}

function resolveArtifactPath(): string {
	if (typeof process !== 'undefined' && Array.isArray(process.argv) && process.argv.length > 1) {
		const script = process.argv[1];
		if (script) {
			return script;
		}
	}
	return embeddedMetadata.artifact.path;
}

function buildMetadataPayload() {
	const invocation = { ...embeddedMetadata.invocation };
	const path = resolveArtifactPath();
	if (artifactKind === 'template' && path) {
		invocation.outputPath = invocation.outputPath ?? path;
	} else if (artifactKind === 'bundle' && path) {
		invocation.bundle = invocation.bundle ?? path;
	} else if (artifactKind === 'binary' && path) {
		invocation.compile = invocation.compile ?? path;
	}
	return {
		...embeddedMetadata,
		artifact: {
			path,
			kind: artifactKind,
		},
		invocation,
	};
}

async function ensureRuntime(): Promise<Awaited<ReturnType<typeof createRuntime>>> {
	return await createRuntime({
		servers: [normalizeEmbeddedServer(embeddedServer)],
	});
}

async function invokeWithTimeout<T>(call: Promise<T>, timeout: number): Promise<T> {
	if (!Number.isFinite(timeout) || timeout <= 0) {
		return await call;
	}
	let timer: ReturnType<typeof setTimeout> | undefined;
	try {
		return await Promise.race([
			call,
			new Promise<never>((_, reject) => {
				timer = setTimeout(() => {
					reject(new Error('Call timed out after ' + timeout + 'ms.'));
				}, timeout);
			}),
		]);
	} finally {
		if (timer) {
			clearTimeout(timer);
		}
	}
}

async function runCli(): Promise<void> {
	const args = process.argv.slice(2);
	if (args.length === 0) {
		program.outputHelp();
		return;
	}
	await program.parseAsync(process.argv);
}

if (process.env.MCPORTER_DISABLE_AUTORUN !== '1') {
	runCli().catch((error) => {
		const message = error instanceof Error ? error.message : String(error);
		console.error(message);
		process.exit(1);
	});
}
